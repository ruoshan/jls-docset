
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;9.&nbsp;Interfaces</title>
      <link rel="stylesheet" type="text/css" href="../../../javaspec.css">
      <meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
      <link rel="home" href="index.html" title="The Java&reg; Language Specification">
      <link rel="up" href="index.html" title="The Java&reg; Language Specification">
      <link rel="prev" href="jls-8.html" title="Chapter&nbsp;8.&nbsp;Classes">
      <link rel="next" href="jls-10.html" title="Chapter&nbsp;10.&nbsp;Arrays">
      <link rel="copyright" href="spec-frontmatter.html" title="Legal Notice">
   <script>window.ohcglobal || document.write('<script src="../../../../../en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" id="logo"><img src="../../../../webdesign/other/im/oralogo_small.gif" alt="Oracle Logo"><br><p><a href="https://docs.oracle.com/en/java/javase/17/">Java SE</a> &gt; <a href="https://docs.oracle.com/javase/specs/index.html">Java SE Specifications</a> &gt; <a href="index.html">Java Language Specification</a></p>
      </div>
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;9.&nbsp;Interfaces</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="jls-8.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="jls-10.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div lang="en" class="chapter">
         <div class="titlepage">
            <div>
               <div>
                  <h1 class="title"><a name="jls-9"></a>Chapter&nbsp;9.&nbsp;Interfaces
                  </h1>
               </div>
            </div>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl class="toc">
               <dt><span class="section"><a href="jls-9.html#jls-9.1">9.1. Interface Declarations</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-9.html#jls-9.1.1">9.1.1. Interface Modifiers</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-9.html#jls-9.1.1.1">9.1.1.1. <code class="literal">abstract</code> Interfaces</a></span></dt>
                           <dt><span class="section"><a href="jls-9.html#jls-9.1.1.2">9.1.1.2. <code class="literal">strictfp</code> Interfaces</a></span></dt>
                           <dt><span class="section"><a href="jls-9.html#jls-9.1.1.3">9.1.1.3. <code class="literal">static</code> Interfaces</a></span></dt>
                           <dt><span class="section"><a href="jls-9.html#jls-9.1.1.4">9.1.1.4. <code class="literal">sealed</code> and <code class="literal">non-sealed</code> Interfaces</a></span></dt>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="jls-9.html#jls-9.1.2">9.1.2. Generic Interfaces and Type Parameters</a></span></dt>
                     <dt><span class="section"><a href="jls-9.html#jls-9.1.3">9.1.3. Superinterfaces and Subinterfaces</a></span></dt>
                     <dt><span class="section"><a href="jls-9.html#jls-9.1.4">9.1.4. Permitted Direct Subclasses and Subinterfaces</a></span></dt>
                     <dt><span class="section"><a href="jls-9.html#jls-9.1.5">9.1.5. Interface Body and Member Declarations</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-9.html#jls-9.2">9.2. Interface Members</a></span></dt>
               <dt><span class="section"><a href="jls-9.html#jls-9.3">9.3. Field (Constant) Declarations</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-9.html#jls-9.3.1">9.3.1. Initialization of Fields in Interfaces</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-9.html#jls-9.4">9.4. Method Declarations</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-9.html#jls-9.4.1">9.4.1. Inheritance and Overriding</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-9.html#jls-9.4.1.1">9.4.1.1. Overriding (by Instance Methods)</a></span></dt>
                           <dt><span class="section"><a href="jls-9.html#jls-9.4.1.2">9.4.1.2. Requirements in Overriding</a></span></dt>
                           <dt><span class="section"><a href="jls-9.html#jls-9.4.1.3">9.4.1.3. Inheriting Methods with Override-Equivalent Signatures</a></span></dt>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="jls-9.html#jls-9.4.2">9.4.2. Overloading</a></span></dt>
                     <dt><span class="section"><a href="jls-9.html#jls-9.4.3">9.4.3. Interface Method Body</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-9.html#jls-9.5">9.5. Member Class and Interface Declarations</a></span></dt>
               <dt><span class="section"><a href="jls-9.html#jls-9.6">9.6. Annotation Interfaces</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-9.html#jls-9.6.1">9.6.1. Annotation Interface Elements</a></span></dt>
                     <dt><span class="section"><a href="jls-9.html#jls-9.6.2">9.6.2. Defaults for Annotation Interface Elements</a></span></dt>
                     <dt><span class="section"><a href="jls-9.html#jls-9.6.3">9.6.3. Repeatable Annotation Interfaces</a></span></dt>
                     <dt><span class="section"><a href="jls-9.html#jls-9.6.4">9.6.4. Predefined Annotation Interfaces</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-9.html#jls-9.6.4.1">9.6.4.1. <code class="literal">@Target</code></a></span></dt>
                           <dt><span class="section"><a href="jls-9.html#jls-9.6.4.2">9.6.4.2. <code class="literal">@Retention</code></a></span></dt>
                           <dt><span class="section"><a href="jls-9.html#jls-9.6.4.3">9.6.4.3. <code class="literal">@Inherited</code></a></span></dt>
                           <dt><span class="section"><a href="jls-9.html#jls-9.6.4.4">9.6.4.4. <code class="literal">@Override</code></a></span></dt>
                           <dt><span class="section"><a href="jls-9.html#jls-9.6.4.5">9.6.4.5. <code class="literal">@SuppressWarnings</code></a></span></dt>
                           <dt><span class="section"><a href="jls-9.html#jls-9.6.4.6">9.6.4.6. <code class="literal">@Deprecated</code></a></span></dt>
                           <dt><span class="section"><a href="jls-9.html#jls-9.6.4.7">9.6.4.7. <code class="literal">@SafeVarargs</code></a></span></dt>
                           <dt><span class="section"><a href="jls-9.html#jls-9.6.4.8">9.6.4.8. <code class="literal">@Repeatable</code></a></span></dt>
                           <dt><span class="section"><a href="jls-9.html#jls-9.6.4.9">9.6.4.9. <code class="literal">@FunctionalInterface</code></a></span></dt>
                        </dl>
                     </dd>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-9.html#jls-9.7">9.7. Annotations</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-9.html#jls-9.7.1">9.7.1. Normal Annotations</a></span></dt>
                     <dt><span class="section"><a href="jls-9.html#jls-9.7.2">9.7.2. Marker Annotations</a></span></dt>
                     <dt><span class="section"><a href="jls-9.html#jls-9.7.3">9.7.3. Single-Element Annotations</a></span></dt>
                     <dt><span class="section"><a href="jls-9.html#jls-9.7.4">9.7.4. Where Annotations May Appear</a></span></dt>
                     <dt><span class="section"><a href="jls-9.html#jls-9.7.5">9.7.5. Multiple Annotations of the Same Interface</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-9.html#jls-9.8">9.8. Functional Interfaces</a></span></dt>
               <dt><span class="section"><a href="jls-9.html#jls-9.9">9.9. Function Types</a></span></dt>
            </dl>
         </div>
         <p class="norm"><a name="jls-9-100"></a>
            An interface declaration defines a new interface  that can be
            implemented by one or more classes. Programs can use interfaces to
            provide a common supertype for otherwise unrelated classes, and
            to make it unnecessary for related classes to share a common
            <code class="literal">abstract</code> superclass.
         </p>
         <p class="norm"><a name="jls-9-110"></a>
            Interfaces have no instance variables, and typically declare one or more
            <code class="literal">abstract</code> methods; otherwise unrelated classes can implement an interface
            by providing implementations for its <code class="literal">abstract</code> methods. Interfaces may
            not be directly instantiated.
         </p>
         <p class="norm"><a name="jls-9-120"></a>
            A <span class="emphasis"><em>top level interface</em></span> (<a class="xref" href="jls-7.html#jls-7.6" title="7.6.&nbsp;Top Level Class and Interface Declarations">&sect;7.6</a>)
            is an interface declared directly in a compilation unit.
         </p>
         <p class="norm"><a name="jls-9-130"></a>
            A <span class="emphasis"><em>nested interface</em></span> is any interface whose
            declaration occurs within the body of another class or interface
            declaration. A nested interface may be a member interface
            (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Class and Interface Declarations">&sect;8.5</a>, <a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Class and Interface Declarations">&sect;9.5</a>) or a
            local interface (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class and Interface Declarations">&sect;14.3</a>).
         </p>
         <p class="norm"><a name="jls-9-140"></a>
            An <span class="emphasis"><em>annotation interface</em></span> (<a class="xref" href="jls-9.html#jls-9.6" title="9.6.&nbsp;Annotation Interfaces">&sect;9.6</a>)
            is an interface declared with distinct syntax, intended to be
            implemented by reflective representations of <span class="emphasis"><em>annotations</em></span>
            (<a class="xref" href="jls-9.html#jls-9.7" title="9.7.&nbsp;Annotations">&sect;9.7</a>).
         </p>
         <p class="norm"><a name="jls-9-150"></a>
            This chapter discusses the common semantics of all interfaces. Details
            that are specific to particular kinds of interfaces are discussed in the
            sections dedicated to these constructs.
         </p>
         <p class="norm"><a name="jls-9-160"></a>
            An interface may be declared to be a <span class="emphasis"><em>direct
                  extension</em></span> of one or more other interfaces, meaning that it
            inherits all the member classes and interfaces, instance methods, and
            <code class="literal">static</code> fields of the interfaces it extends, except for any members
            that it may override or hide.
         </p>
         <p class="norm"><a name="jls-9-170"></a>
            A class may be declared to <span class="emphasis"><em>directly implement</em></span> one
            or more interfaces (<a class="xref" href="jls-8.html#jls-8.1.5" title="8.1.5.&nbsp;Superinterfaces">&sect;8.1.5</a>), meaning that any
            instance of the class implements all the <code class="literal">abstract</code> methods specified
            by the interface or interfaces. A class necessarily implements all the
            interfaces that its direct superclasses and direct superinterfaces do.
            This (multiple) interface inheritance allows objects to support (multiple)
            common behaviors without sharing a superclass.
         </p>
         <p class="norm"><a name="jls-9-180"></a>
            Unlike a class, an interface cannot be declared <code class="literal">final</code>. However, an
            interface may be declared <code class="literal">sealed</code> (<a class="xref" href="jls-9.html#jls-9.1.1.4" title="9.1.1.4.&nbsp;sealed and non-sealed Interfaces">&sect;9.1.1.4</a>) to
            limit its subclasses and subinterfaces.
         </p>
         <p class="norm"><a name="jls-9-190"></a>
            A variable whose declared type is an interface type may have as its
            value a reference to any instance of a class which implements the
            specified interface. It is not sufficient that the class happen to
            implement all the <code class="literal">abstract</code> methods of the interface; the class or
            one of its superclasses must actually be declared to implement the
            interface, or else the class is not considered to implement the
            interface.
         </p>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-9.1"></a>9.1.&nbsp;Interface Declarations
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-9.1-100"></a>
               An <span class="emphasis"><em>interface declaration</em></span> specifies an interface.
            </p>
            <p class="norm-static"><a name="jls-9.1-110"></a>
               There are two kinds of interface declarations:
               <span class="emphasis"><em>normal interface declarations</em></span> and
               <span class="emphasis"><em>annotation interface declarations</em></span>
               (<a class="xref" href="jls-9.html#jls-9.6" title="9.6.&nbsp;Annotation Interfaces">&sect;9.6</a>).
            </p>
            <div id="jls-9.1-120" class="productionset"><a name="jls-9.1-120"></a>
                 
               <div class="production"><a name="jls-InterfaceDeclaration"></a>
                      
                  <div class="lhs">InterfaceDeclaration:</div>
                      
                  <div class="rhs">
                           <a href="jls-9.html#jls-NormalInterfaceDeclaration" title="NormalInterfaceDeclaration">NormalInterfaceDeclaration</a> <br>
                           <a href="jls-9.html#jls-AnnotationInterfaceDeclaration" title="AnnotationInterfaceDeclaration">AnnotationInterfaceDeclaration</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-NormalInterfaceDeclaration"></a>
                      
                  <div class="lhs">NormalInterfaceDeclaration:</div>
                      
                  <div class="rhs">
                           {<a href="jls-9.html#jls-InterfaceModifier" title="InterfaceModifier">InterfaceModifier</a>} 
                           <code class="literal">interface</code> <a href="jls-3.html#jls-TypeIdentifier" title="TypeIdentifier">TypeIdentifier</a>
                           [<a href="jls-8.html#jls-TypeParameters" title="TypeParameters">TypeParameters</a>]
                           
                           [<a href="jls-9.html#jls-InterfaceExtends" title="InterfaceExtends">InterfaceExtends</a>]
                           [<a href="jls-9.html#jls-InterfacePermits" title="InterfacePermits">InterfacePermits</a>]
                           <a href="jls-9.html#jls-InterfaceBody" title="InterfaceBody">InterfaceBody</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-9.1-200"></a>
               The <span class="emphasis"><em>TypeIdentifier</em></span> in an interface declaration specifies the name of
               the interface.
            </p>
            <p class="norm-error"><a name="jls-9.1-210"></a>
               It is a compile-time error if an interface has the same simple name as
               any of its enclosing classes or interfaces.
            </p>
            <p class="norm-static"><a name="jls-9.1-300"></a>
               The scope and shadowing of an interface declaration is specified in
               <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a> and <a class="xref" href="jls-6.html#jls-6.4.1" title="6.4.1.&nbsp;Shadowing">&sect;6.4.1</a>.
            </p>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.1.1"></a>9.1.1.&nbsp;Interface Modifiers
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.1.1-100"></a>
                  An interface declaration may include <span class="emphasis"><em>interface
                        modifiers</em></span>.
               </p>
               <div id="jls-9.1.1-110" class="productionset"><a name="jls-9.1.1-110"></a>
                    
                  <div class="production"><a name="jls-InterfaceModifier"></a>
                         
                     <div class="lhs">InterfaceModifier:</div>
                         
                     <div class="rhs">
                              (one of) <br>
                              <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a> <code class="literal">public</code> <code class="literal">protected</code> <code class="literal">private</code> <br>
                              <code class="literal">abstract</code> <code class="literal">static</code> <code class="literal">sealed</code> <code class="literal">non-sealed</code> <code class="literal">strictfp</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-9.1.1-200"></a>
                  The rules concerning annotation modifiers for an interface declaration
                  are specified in <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a> and
                  <a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Interface">&sect;9.7.5</a>.
               </p>
               <p class="norm-static"><a name="jls-9.1.1-210"></a>
                  The access modifier <code class="literal">public</code> (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) pertains
                  only to top level interfaces (<a class="xref" href="jls-7.html#jls-7.6" title="7.6.&nbsp;Top Level Class and Interface Declarations">&sect;7.6</a>) and member
                  interfaces (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Class and Interface Declarations">&sect;8.5</a>, <a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Class and Interface Declarations">&sect;9.5</a>),
                  not to local interfaces (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class and Interface Declarations">&sect;14.3</a>).
               </p>
               <p class="norm-static"><a name="jls-9.1.1-220"></a>
                  The access modifiers <code class="literal">protected</code> and <code class="literal">private</code> pertain only to member
                  interfaces.
               </p>
               <p class="norm-static"><a name="jls-9.1.1-230"></a>
                  The modifier <code class="literal">static</code> pertains only to member interfaces and local
                  interfaces.
               </p>
               <p class="norm-error"><a name="jls-9.1.1-300"></a>
                  It is a compile-time error if the same keyword appears more than once
                  as a modifier for an interface declaration, or if a interface
                  declaration has more than one of the access modifiers <code class="literal">public</code>,
                  <code class="literal">protected</code>, and <code class="literal">private</code>.
               </p>
               <p class="norm-error"><a name="jls-9.1.1-310"></a>
                  It is a compile-time error if an interface declaration has more than one
                  of the modifiers <code class="literal">sealed</code> and <code class="literal">non-sealed</code>.
               </p>
               <p class="note">If two or more (distinct) interface modifiers appear
                  in an interface declaration, then it is customary, though not
                  required, that they appear in the order consistent with that shown
                  above in the production for <span class="emphasis"><em>InterfaceModifier</em></span>.
               </p>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.1.1.1"></a>9.1.1.1.&nbsp;<code class="literal">abstract</code> Interfaces
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-9.1.1.1-100"></a>
                     Every interface is implicitly <code class="literal">abstract</code>.
                  </p>
                  <p class="note">This modifier is obsolete and should not be used in
                     new code.
                  </p>
               </div>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.1.1.2"></a>9.1.1.2.&nbsp;<code class="literal">strictfp</code> Interfaces
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-9.1.1.2-100"></a>
                     The <code class="literal">strictfp</code> modifier on an interface declaration is obsolete
                     and should not be used in new code. Its presence or absence has no
                     effect at compile time or run time.
                  </p>
               </div>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.1.1.3"></a>9.1.1.3.&nbsp;<code class="literal">static</code> Interfaces
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-9.1.1.3-100"></a>
                     A nested interface is implicitly <code class="literal">static</code>. That is, every member
                     interface and local interface is <code class="literal">static</code>. It is permitted for the
                     declaration of a member interface to redundantly specify the <code class="literal">static</code>
                     modifier (<a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Class and Interface Declarations">&sect;9.5</a>), but it is not permitted for the
                     declaration of a local interface (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class and Interface Declarations">&sect;14.3</a>).
                  </p>
                  <p class="norm-static"><a name="jls-9.1.1.3-110"></a>
                     Because a nested interface is <code class="literal">static</code>, it has no immediately
                     enclosing instance (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>). References from a
                     nested interface to type parameters, instance variables, local
                     variables, formal parameters, exception parameters, or instance
                     methods in lexically enclosing class, interface, or method
                     declarations are disallowed (<a class="xref" href="jls-6.html#jls-6.5.5.1" title="6.5.5.1.&nbsp;Simple Type Names">&sect;6.5.5.1</a>, <a class="xref" href="jls-6.html#jls-6.5.6.1" title="6.5.6.1.&nbsp;Simple Expression Names">&sect;6.5.6.1</a>, <a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>).
                  </p>
               </div>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.1.1.4"></a>9.1.1.4.&nbsp;<code class="literal">sealed</code> and <code class="literal">non-sealed</code> Interfaces
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-9.1.1.4-100"></a>
                     An interface can be declared <code class="literal">sealed</code> if all its direct subclasses and
                     direct subinterfaces are known when the interface is declared (<a class="xref" href="jls-9.html#jls-9.1.4" title="9.1.4.&nbsp;Permitted Direct Subclasses and Subinterfaces">&sect;9.1.4</a>), and no other direct subclasses or direct
                     subinterfaces are desired or required.
                  </p>
                  <p class="note">It is useful to recall that a class is said to be a
                     <span class="emphasis"><em>direct subclass</em></span> of its direct superinterfaces
                     (<a class="xref" href="jls-8.html#jls-8.1.5" title="8.1.5.&nbsp;Superinterfaces">&sect;8.1.5</a>).
                  </p>
                  <p class="norm-static"><a name="jls-9.1.1.4-200"></a>
                     An interface is <span class="emphasis"><em>freely extensible</em></span> if none of its
                     direct superinterfaces are <code class="literal">sealed</code> (<a class="xref" href="jls-9.html#jls-9.1.3" title="9.1.3.&nbsp;Superinterfaces and Subinterfaces">&sect;9.1.3</a>), and
                     it is not <code class="literal">sealed</code> itself.
                  </p>
                  <p class="norm-static"><a name="jls-9.1.1.4-210"></a>
                     An interface that has a <code class="literal">sealed</code> direct superinterface is
                     freely extensible if and only if it is declared <code class="literal">non-sealed</code>.
                  </p>
                  <p class="norm-error"><a name="jls-9.1.1.4-220"></a>
                     It is a compile-time error if an interface has a <code class="literal">sealed</code> direct
                     superinterface and is not declared <code class="literal">sealed</code> or <code class="literal">non-sealed</code>.
                  </p>
                  <p class="norm-error"><a name="jls-9.1.1.4-230"></a>
                     It is a compile-time error if an interface is declared <code class="literal">non-sealed</code> but
                     has no <code class="literal">sealed</code> direct superinterface.
                  </p>
               </div>
            </div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.1.2"></a>9.1.2.&nbsp;Generic Interfaces and Type Parameters
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.1.2-100"></a>
                  An interface is <span class="emphasis"><em>generic</em></span> if the interface declaration
                  declares one or more type variables (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>).
               </p>
               <p class="norm-static"><a name="jls-9.1.2-110"></a>These type
                  variables are known as the <span class="emphasis"><em>type parameters</em></span> of the
                  interface. The type parameter section follows the interface name and
                  is delimited by angle brackets.
               </p>
               <p class="note">The following productions from
                  <a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a> and <a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a> are shown
                  here for convenience:
               </p>
               <div id="d5e17366" class="productionset"><a name="d5e17366"></a>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">TypeParameters:</div>
                            
                        <div class="rhs">
                                 <code class="literal">&lt;</code> <a href="jls-8.html#jls-TypeParameterList" title="TypeParameterList">TypeParameterList</a> <code class="literal">&gt;</code>
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">TypeParameterList:</div>
                            
                        <div class="rhs">
                                 <a href="jls-4.html#jls-TypeParameter" title="TypeParameter">TypeParameter</a> {<code class="literal">,</code> <a href="jls-4.html#jls-TypeParameter" title="TypeParameter">TypeParameter</a>}
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                            
                        <div class="lhs">TypeParameter:</div>
                            
                        <div class="rhs">
                                 {<a href="jls-4.html#jls-TypeParameterModifier" title="TypeParameterModifier">TypeParameterModifier</a>}
                                 <a href="jls-3.html#jls-TypeIdentifier" title="TypeIdentifier">TypeIdentifier</a>
                                 [<a href="jls-4.html#jls-TypeBound" title="TypeBound">TypeBound</a>]
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">TypeParameterModifier:</div>
                            
                        <div class="rhs">
                                 <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">TypeBound:</div>
                            
                        <div class="rhs">
                                 <code class="literal">extends</code> <a href="jls-4.html#jls-TypeVariable" title="TypeVariable">TypeVariable</a> <br>
                           
                                 <code class="literal">extends</code> <a href="jls-4.html#jls-ClassOrInterfaceType" title="ClassOrInterfaceType">ClassOrInterfaceType</a> {<a href="jls-4.html#jls-AdditionalBound" title="AdditionalBound">AdditionalBound</a>}
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">AdditionalBound:</div>
                            
                        <div class="rhs">
                                 <code class="literal">&amp;</code> <a href="jls-4.html#jls-InterfaceType" title="InterfaceType">InterfaceType</a>
                               
                        </div>
                          
                     </div>
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-9.1.2-120"></a>
                  The rules concerning annotation modifiers for a type parameter declaration
                  are specified in <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a> and <a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Interface">&sect;9.7.5</a>.
               </p>
               <p class="norm-static"><a name="jls-9.1.2-200"></a>
                  In an interface's type parameter section, a type variable <span class="type">T</span>
                  <span class="emphasis"><em>directly depends</em></span> on a type variable <span class="type">S</span> if <span class="type">S</span> is
                  the bound of <span class="type">T</span>, while <span class="type">T</span> <span class="emphasis"><em>depends</em></span> on <span class="type">S</span> if
                  either <span class="type">T</span> directly depends on <span class="type">S</span> or <span class="type">T</span> directly depends on a type
                  variable <span class="type">U</span> that depends on <span class="type">S</span> (using this definition
                  recursively). It is a compile-time error if a type variable in a
                  interface's type parameter section depends on itself.
               </p>
               <p class="norm-static"><a name="jls-9.1.2-210"></a>
                  The scope and shadowing of an interface's type parameter is specified
                  in <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a> and <a class="xref" href="jls-6.html#jls-6.4.1" title="6.4.1.&nbsp;Shadowing">&sect;6.4.1</a>.
               </p>
               <p class="norm-static"><a name="jls-9.1.2-220"></a>
                  References to an interface's type parameter from a static context or
                  a nested class or interface are restricted, as specified in
                  <a class="xref" href="jls-6.html#jls-6.5.5.1" title="6.5.5.1.&nbsp;Simple Type Names">&sect;6.5.5.1</a>.
               </p>
               <p class="norm-dynamic"><a name="jls-9.1.2-300"></a>
                  A generic interface declaration defines a set of parameterized types
                  (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>), one for each possible parameterization of
                  the type parameter section by type arguments. All of these
                  parameterized types share the same interface at run time.
               </p>
            </div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.1.3"></a>9.1.3.&nbsp;Superinterfaces and Subinterfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.1.3-100"></a>
                  If an <code class="literal">extends</code> clause is provided, then the interface being declared
                  extends each of the specified interface types and therefore inherits the
                  member classes, member interfaces, instance methods, and <code class="literal">static</code> fields of
                  each of those interface types.
               </p>
               <p class="norm-static"><a name="jls-9.1.3-110"></a>
                  The specified interface types are the <span class="emphasis"><em>direct
                        superinterface types</em></span> of the interface being declared.
               </p>
               <p class="norm-static"><a name="jls-9.1.3-120"></a>
                  Any class that <code class="literal">implements</code> the declared interface is also considered
                  to implement all the interfaces that this interface <code class="literal">extends</code>.
               </p>
               <div id="jls-9.1.3-130" class="productionset"><a name="jls-9.1.3-130"></a>
                    
                  <div class="production"><a name="jls-InterfaceExtends"></a>
                         
                     <div class="lhs">InterfaceExtends:</div>
                         
                     <div class="rhs">
                              <code class="literal">extends</code> <a href="jls-8.html#jls-InterfaceTypeList" title="InterfaceTypeList">InterfaceTypeList</a>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="note">The following production from
                  <a class="xref" href="jls-8.html#jls-8.1.5" title="8.1.5.&nbsp;Superinterfaces">&sect;8.1.5</a> is shown here for convenience:
               </p>
               <div id="d5e17415" class="productionset"><a name="d5e17415"></a>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">InterfaceTypeList:</div>
                            
                        <div class="rhs">
                                 <a href="jls-4.html#jls-InterfaceType" title="InterfaceType">InterfaceType</a> {<code class="literal">,</code> <a href="jls-4.html#jls-InterfaceType" title="InterfaceType">InterfaceType</a>}
                               
                        </div>
                          
                     </div>
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-9.1.3-200"></a>
                  Each <span class="emphasis"><em>InterfaceType</em></span> in the <code class="literal">extends</code> clause of an interface declaration
                  must name an accessible interface (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>),
                  or a compile-time error occurs.
               </p>
               <p class="norm-error"><a name="jls-9.1.3-210"></a>
                  It is a compile-time error if any <span class="emphasis"><em>InterfaceType</em></span> names a interface
                  that is <code class="literal">sealed</code> (<a class="xref" href="jls-9.html#jls-9.1.1.4" title="9.1.1.4.&nbsp;sealed and non-sealed Interfaces">&sect;9.1.1.4</a>) and the interface being
                  declared is not a permitted direct subinterface of the named interface
                  (<a class="xref" href="jls-9.html#jls-9.1.4" title="9.1.4.&nbsp;Permitted Direct Subclasses and Subinterfaces">&sect;9.1.4</a>).
               </p>
               <p class="norm-error"><a name="jls-9.1.3-220"></a>
                  If an <span class="emphasis"><em>InterfaceType</em></span> has type arguments, it must denote a well-formed
                  parameterized type (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>), and none of the type
                  arguments may be wildcard type arguments, or a compile-time error
                  occurs.
               </p>
               <p class="norm-static"><a name="jls-9.1.3-300"></a>
                  One interface is a <span class="emphasis"><em>direct superinterface</em></span> of another
                  interface if the first interface is named by one of the direct
                  superinterface types of the second interface.
               </p>
               <p class="norm-static"><a name="jls-9.1.3-310"></a>
                  The <span class="emphasis"><em>superinterface</em></span> relationship is the transitive
                  closure of the direct superinterface relationship. An interface <span class="type">I</span>
                  is a superinterface of interface <span class="type">K</span> if either of the following is
                  true:
               </p>
               <div class="norm">
                  <ul class="norm" style="list-style-type: disc; ">
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.1.3-310-A"></a>
                                 <span class="type">I</span> is a direct superinterface of <span class="type">K</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.1.3-310-B"></a>
                                 Where <span class="type">J</span> is a direct superinterface of <span class="type">K</span>,
                                 <span class="type">I</span> is a superinterface of <span class="type">J</span>,
                                 applying this definition recursively.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-9.1.3-320"></a>
                  An interface is said to be a <span class="emphasis"><em>direct subinterface</em></span>
                  of its direct superinterface, and a <span class="emphasis"><em>subinterface</em></span> of
                  each of its superinterfaces.
               </p>
               <p class="norm-static"><a name="jls-9.1.3-330"></a>
                  While every class is an extension of class <code class="literal">Object</code>, there is no single
                  interface of which all interfaces are extensions.
               </p>
               <p class="norm-static"><a name="jls-9.1.3-400"></a>
                  An interface <span class="type">I</span> <span class="emphasis"><em>directly depends</em></span> on a class or
                  interface <span class="type">A</span> if <span class="type">A</span> is mentioned in the <code class="literal">extends</code> clause of <span class="type">I</span>
                  either as a superinterface or as a qualifier in the fully
                  qualified form of a superinterface name.
               </p>
               <p class="norm-static"><a name="jls-9.1.3-410"></a>
                  An interface <span class="type">I</span> <span class="emphasis"><em>depends</em></span> on a class or interface <span class="type">A</span>
                  if any of the following is true:
               </p>
               <div class="norm">
                  <ul class="norm" style="list-style-type: disc; ">
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.1.3-410-A"></a>
                                 <span class="type">I</span> directly depends on <span class="type">A</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.1.3-410-B"></a>
                                 <span class="type">I</span> directly depends on a class <span class="type">C</span> that depends on <span class="type">A</span>
                                 (<a class="xref" href="jls-8.html#jls-8.1.5" title="8.1.5.&nbsp;Superinterfaces">&sect;8.1.5</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.1.3-410-C"></a>
                                 <span class="type">I</span> directly depends on an interface <span class="type">J</span> that depends on <span class="type">A</span>,
                                 applying this definition recursively.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-error"><a name="jls-9.1.3-420"></a>
                  It is a compile-time error if an interface depends on itself.
               </p>
               <p class="norm-dynamic"><a name="jls-9.1.3-430"></a>
                  If circularly declared interfaces are detected at run time,
                  as interfaces are loaded, then a <code class="literal">ClassCircularityError</code> is thrown
                  (<a class="xref" href="jls-12.html#jls-12.2.1" title="12.2.1.&nbsp;The Loading Process">&sect;12.2.1</a>).
               </p>
            </div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.1.4"></a>9.1.4.&nbsp;Permitted Direct Subclasses and Subinterfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.1.4-100"></a>
                  The optional <code class="literal">permits</code> clause in a normal interface declaration
                  specifies all the classes and interfaces intended as direct subclasses
                  and direct subinterfaces of the interface being declared (<a class="xref" href="jls-9.html#jls-9.1.1.4" title="9.1.1.4.&nbsp;sealed and non-sealed Interfaces">&sect;9.1.1.4</a>).
               </p>
               <div id="jls-9.1.4-110" class="productionset"><a name="jls-9.1.4-110"></a>
                    
                  <div class="production"><a name="jls-InterfacePermits"></a>
                         
                     <div class="lhs">InterfacePermits:</div>
                         
                     <div class="rhs">
                              <code class="literal">permits</code> <a href="jls-6.html#jls-TypeName" title="TypeName">TypeName</a> 
                              {<code class="literal">,</code> <a href="jls-6.html#jls-TypeName" title="TypeName">TypeName</a>} 
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-9.1.4-200"></a>
                  It is a compile-time error if an interface declaration has a <code class="literal">permits</code> clause
                  but no <code class="literal">sealed</code> modifier.
               </p>
               <p class="norm-error"><a name="jls-9.1.4-210"></a>
                  Every <span class="emphasis"><em>TypeName</em></span> must name an accessible class or interface (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>), or a compile-time error occurs.
               </p>
               <p class="norm-error"><a name="jls-9.1.4-220"></a>
                  It is a compile-time error if the same class or interface is specified
                  more than once in a <code class="literal">permits</code> clause. This is true even if the class
                  or interface is named in different ways.
               </p>
               <div class="informalexample">
                  <p class="note">The canonical name of a class or interface does not
                     need to be used in a <code class="literal">permits</code> clause, but a <code class="literal">permits</code> clause can only
                     specify a class or interface once. For example, the following program
                     fails to compile:
                  </p><pre class="programlisting">
package p;

sealed interface I permits C, D, p.C {}  // error

non-sealed class C implements I {}  
non-sealed class D implements I {}
</pre></div>
               <p class="norm-error"><a name="jls-9.1.4-300"></a>
                  If a <code class="literal">sealed</code> interface <span class="type">I</span> is associated with a named module (<a class="xref" href="jls-7.html#jls-7.3" title="7.3.&nbsp;Compilation Units">&sect;7.3</a>), then every class or interface specified in the
                  <code class="literal">permits</code> clause of <span class="type">I</span>'s declaration must be associated with the same
                  module as <span class="type">I</span>, or a compile-time error occurs.
               </p>
               <p class="norm-error"><a name="jls-9.1.4-310"></a>
                  If a <code class="literal">sealed</code> interface <span class="type">I</span> is associated with an unnamed module
                  (<a class="xref" href="jls-7.html#jls-7.7.5" title="7.7.5.&nbsp;Unnamed Modules">&sect;7.7.5</a>), then every class or interface specified
                  in the <code class="literal">permits</code> clause of <span class="type">I</span>'s declaration must belong to the same
                  package as <span class="type">I</span>, or a compile-time error occurs.
               </p>
               <p class="note">A <code class="literal">sealed</code> interface and its direct subclasses and
                  direct subinterfaces need to refer to each other in a circular
                  fashion, in <code class="literal">permits</code>, <code class="literal">implements</code>, and <code class="literal">extends</code> clauses,
                  respectively. Therefore, in a modular codebase, they must be
                  co-located in the same module, as classes and interfaces in different
                  modules cannot refer to each other in a circular fashion. Co-location
                  is desirable in any case because a sealed interface hierarchy should
                  always be declared within a single maintenance domain, where the same
                  developer or group of developers is responsible for maintaining the
                  hierarchy. A named module typically represents a maintenance domain in
                  a modular codebase.
               </p>
               <p class="norm-static"><a name="jls-9.1.4-400"></a>
                  If the declaration of a <code class="literal">sealed</code> interface <span class="type">I</span> has a <code class="literal">permits</code> clause,
                  then the <span class="emphasis"><em>permitted direct subclasses and
                        subinterfaces</em></span> of <span class="type">I</span> are the classes and interfaces
                  specified by the <code class="literal">permits</code> clause.
               </p>
               <p class="norm-error"><a name="jls-9.1.4-410"></a>
                  Every permitted direct subclass and subinterface specified by the
                  <code class="literal">permits</code> clause must be a direct subclass of <span class="type">I</span> (<a class="xref" href="jls-8.html#jls-8.1.5" title="8.1.5.&nbsp;Superinterfaces">&sect;8.1.5</a>) or a direct subinterface of <span class="type">I</span> (<a class="xref" href="jls-9.html#jls-9.1.3" title="9.1.3.&nbsp;Superinterfaces and Subinterfaces">&sect;9.1.3</a>), or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-9.1.4-500"></a>
                  If the declaration of a <code class="literal">sealed</code> interface <span class="type">I</span> lacks a <code class="literal">permits</code>
                  clause, then the permitted direct subclasses and subinterfaces of <span class="type">I</span>
                  are those classes and interfaces declared in the same compilation unit
                  as <span class="type">I</span> (<a class="xref" href="jls-7.html#jls-7.3" title="7.3.&nbsp;Compilation Units">&sect;7.3</a>) which have a canonical name (<a class="xref" href="jls-6.html#jls-6.7" title="6.7.&nbsp;Fully Qualified Names and Canonical Names">&sect;6.7</a>) and whose direct superinterfaces include <span class="type">I</span>.
               </p>
               <p class="note">That is, the permitted direct subclasses and
                  subinterfaces are inferred as the classes and interfaces in the same
                  compilation unit that specify <span class="type">I</span> as a direct superinterface. The
                  requirement for a canonical name means that no local classes, local
                  interfaces, or anonymous classes will be considered.
               </p>
               <p class="norm-error"><a name="jls-9.1.4-510"></a>
                  It is a compile-time error if the declaration of a <code class="literal">sealed</code> interface <span class="type">I</span>
                  lacks a <code class="literal">permits</code> clause and <span class="type">I</span> has no permitted direct subclasses
                  or subinterfaces.
               </p>
            </div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.1.5"></a>9.1.5.&nbsp;Interface Body and Member Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.1.5-100"></a>
                  An <span class="emphasis"><em>interface body</em></span> may contain declarations of
                  members of the interface, that is, fields (<a class="xref" href="jls-9.html#jls-9.3" title="9.3.&nbsp;Field (Constant) Declarations">&sect;9.3</a>),
                  methods (<a class="xref" href="jls-9.html#jls-9.4" title="9.4.&nbsp;Method Declarations">&sect;9.4</a>), classes, and interfaces
                  (<a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Class and Interface Declarations">&sect;9.5</a>).
               </p>
               <div id="jls-9.1.5-110" class="productionset"><a name="jls-9.1.5-110"></a>
                    
                  <div class="production"><a name="jls-InterfaceBody"></a>
                         
                     <div class="lhs">InterfaceBody:</div>
                         
                     <div class="rhs">
                              <code class="literal">{</code> {<a href="jls-9.html#jls-InterfaceMemberDeclaration" title="InterfaceMemberDeclaration">InterfaceMemberDeclaration</a>} <code class="literal">}</code>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-InterfaceMemberDeclaration"></a>
                         
                     <div class="lhs">InterfaceMemberDeclaration:</div>
                         
                     <div class="rhs">
                              <a href="jls-9.html#jls-ConstantDeclaration" title="ConstantDeclaration">ConstantDeclaration</a> <br>
                              <a href="jls-9.html#jls-InterfaceMethodDeclaration" title="InterfaceMethodDeclaration">InterfaceMethodDeclaration</a> <br>
                              <a href="jls-8.html#jls-ClassDeclaration" title="ClassDeclaration">ClassDeclaration</a> <br>
                              <a href="jls-9.html#jls-InterfaceDeclaration" title="InterfaceDeclaration">InterfaceDeclaration</a> <br>
                              <code class="literal">;</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-static"><a name="jls-9.1.5-120"></a>
                  The scope of a declaration of a member <code class="varname">m</code> declared in or inherited by an
                  interface <span class="type">I</span> is specified in <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a>.
               </p>
            </div>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-9.2"></a>9.2.&nbsp;Interface Members
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-9.2-100"></a>
               The members of an interface are:
            </p>
            <div class="norm">
               <ul class="norm" style="list-style-type: disc; ">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.2-100-A"></a>
                              Members declared in the body of the interface declaration
                              (<a class="xref" href="jls-9.html#jls-9.1.5" title="9.1.5.&nbsp;Interface Body and Member Declarations">&sect;9.1.5</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.2-100-B"></a>
                              Members inherited from any direct superinterface types
                              (<a class="xref" href="jls-9.html#jls-9.1.3" title="9.1.3.&nbsp;Superinterfaces and Subinterfaces">&sect;9.1.3</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.2-100-C"></a>
                              If an interface has no direct superinterface types, then the
                              interface implicitly declares a <code class="literal">public</code> <code class="literal">abstract</code> member
                              method <code class="varname">m</code> with signature <span class="type">s</span>, return
                              type <span class="type">r</span>, and <code class="literal">throws</code> clause <span class="type">t</span>
                              corresponding to each <code class="literal">public</code> instance method <code class="varname">m</code> with
                              signature <span class="type">s</span>, return type <span class="type">r</span>, and
                              <code class="literal">throws</code> clause <span class="type">t</span> declared in <code class="literal">Object</code>
                              (<a class="xref" href="jls-4.html#jls-4.3.2" title="4.3.2.&nbsp;The Class Object">&sect;4.3.2</a>), unless an <code class="literal">abstract</code> method with
                              the same signature, same return type, and a compatible <code class="literal">throws</code>
                              clause is explicitly declared by the interface.
                     </p>
                     <p class="norm-error"><a name="jls-9.2-100-C.1"></a>
                              It is a compile-time error if the interface explicitly declares
                              such a method <code class="varname">m</code> in the case where <code class="varname">m</code> is declared to be
                              <code class="literal">final</code> in <code class="literal">Object</code>.
                     </p>
                     <p class="norm-error"><a name="jls-9.2-100-C.2"></a>
                              It is a compile-time error if the interface explicitly declares a
                              method with a signature that is override-equivalent
                              (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) to a <code class="literal">public</code> method of <code class="literal">Object</code>,
                              but which has a different return type, or an incompatible
                              <code class="literal">throws</code> clause, or is not <code class="literal">abstract</code>.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-9.2-110"></a>
               
               The interface inherits, from the interfaces it extends, all members of
               those interfaces, except for (i) fields, classes, and interfaces that
               it hides, (ii) <code class="literal">abstract</code> methods and default methods that it overrides
               (<a class="xref" href="jls-9.html#jls-9.4.1" title="9.4.1.&nbsp;Inheritance and Overriding">&sect;9.4.1</a>), (iii) <code class="literal">private</code> methods, and (iv)
               <code class="literal">static</code> methods.
            </p>
            <p class="norm-static"><a name="jls-9.2-120"></a>
               Fields, methods, member classes, and member interfaces of an interface
               may have the same name, since they are used in different contexts and
               are disambiguated by different lookup procedures (<a class="xref" href="jls-6.html#jls-6.5" title="6.5.&nbsp;Determining the Meaning of a Name">&sect;6.5</a>).
               However, this is discouraged as a matter of style.
            </p>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-9.3"></a>9.3.&nbsp;Field (Constant) Declarations
                     </h2>
                  </div>
               </div>
            </div>
            <div id="jls-9.3-100" class="productionset"><a name="jls-9.3-100"></a>
                 
               <div class="production"><a name="jls-ConstantDeclaration"></a>
                      
                  <div class="lhs">ConstantDeclaration:</div>
                      
                  <div class="rhs">
                           {<a href="jls-9.html#jls-ConstantModifier" title="ConstantModifier">ConstantModifier</a>}
                           <a href="jls-8.html#jls-UnannType" title="UnannType">UnannType</a>
                           <a href="jls-8.html#jls-VariableDeclaratorList" title="VariableDeclaratorList">VariableDeclaratorList</a> <code class="literal">;</code>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-ConstantModifier"></a>
                      
                  <div class="lhs">ConstantModifier:</div>
                      
                  <div class="rhs">
                           (one of) <br>
                           <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a> <code class="literal">public</code> <br>
                           <code class="literal">static</code> <code class="literal">final</code>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="note">See <a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a> for <span class="emphasis"><em>UnannType</em></span>. The
               following productions from <a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a> and <a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a> are shown here for convenience:
            </p>
            <div id="d5e17652" class="productionset"><a name="d5e17652"></a>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">VariableDeclaratorList:</div>
                         
                     <div class="rhs">
                              <a href="jls-8.html#jls-VariableDeclarator" title="VariableDeclarator">VariableDeclarator</a> {<code class="literal">,</code> <a href="jls-8.html#jls-VariableDeclarator" title="VariableDeclarator">VariableDeclarator</a>}
                            
                     </div>
                       
                  </div>
               </div>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">VariableDeclarator:</div>
                         
                     <div class="rhs">
                              <a href="jls-8.html#jls-VariableDeclaratorId" title="VariableDeclaratorId">VariableDeclaratorId</a> [<code class="literal">=</code> <a href="jls-8.html#jls-VariableInitializer" title="VariableInitializer">VariableInitializer</a>]
                            
                     </div>
                       
                  </div>
               </div>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">VariableDeclaratorId:</div>
                         
                     <div class="rhs">
                              <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> [<a href="jls-4.html#jls-Dims" title="Dims">Dims</a>]
                            
                     </div>
                       
                  </div>
               </div>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">Dims:</div>
                         
                     <div class="rhs">
                              {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code> {{<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code>}
                            
                     </div>
                       
                  </div>
               </div>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">VariableInitializer:</div>
                         
                     <div class="rhs">
                              <a href="jls-15.html#jls-Expression" title="Expression">Expression</a> <br>
                              <a href="jls-10.html#jls-ArrayInitializer" title="ArrayInitializer">ArrayInitializer</a>
                            
                     </div>
                       
                  </div>
               </div>
               
            </div>
            <p class="norm-error"><a name="jls-9.3-110"></a>
               The rules concerning annotation modifiers for an interface field declaration
               are specified in <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a> and
               <a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Interface">&sect;9.7.5</a>.
            </p>
            <p class="norm-static"><a name="jls-9.3-120"></a>
               Every field declaration in the body of an interface delaration is
               implicitly <code class="literal">public</code>, <code class="literal">static</code>, and <code class="literal">final</code>. It is permitted to
               redundantly specify any or all of these modifiers for such fields.
            </p>
            <p class="norm-error"><a name="jls-9.3-130"></a>
               It is a compile-time error if the same keyword appears more than once
               as a modifier for a field declaration.
            </p>
            <p class="note">If two or more (distinct) field modifiers appear in
               a field declaration, it is customary, though not required, that they
               appear in the order consistent with that shown above in the production
               for <span class="emphasis"><em>ConstantModifier</em></span>.
            </p>
            <p class="norm-static"><a name="jls-9.3-200"></a>
               
               The declared type of a field is denoted by <span class="emphasis"><em>UnannType</em></span> if no bracket
               pairs appear in <span class="emphasis"><em>UnannType</em></span> and <span class="emphasis"><em>VariableDeclaratorId</em></span>, and is
               specified by <a class="xref" href="jls-10.html#jls-10.2" title="10.2.&nbsp;Array Variables">&sect;10.2</a> otherwise.
            </p>
            <p class="norm-static"><a name="jls-9.3-300"></a>
               The scope and shadowing of an interface field declaration is specified
               in <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a> and <a class="xref" href="jls-6.html#jls-6.4.1" title="6.4.1.&nbsp;Shadowing">&sect;6.4.1</a>.
            </p>
            <p class="norm-static"><a name="jls-9.3-310"></a>
               Because an interface field is <code class="literal">static</code>, its declaration introduces a
               static context (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>), which limits the use of
               constructs that refer to the current object. Notably, the keywords
               <code class="literal">this</code> and <code class="literal">super</code> are prohibited in a static context (<a class="xref" href="jls-15.html#jls-15.8.3" title="15.8.3.&nbsp;this">&sect;15.8.3</a>, <a class="xref" href="jls-15.html#jls-15.11.2" title="15.11.2.&nbsp;Accessing Superclass Members using super">&sect;15.11.2</a>), as are
               unqualified references to instance variables, instance methods, and
               type parameters of lexically enclosing declarations (<a class="xref" href="jls-6.html#jls-6.5.5.1" title="6.5.5.1.&nbsp;Simple Type Names">&sect;6.5.5.1</a>, <a class="xref" href="jls-6.html#jls-6.5.6.1" title="6.5.6.1.&nbsp;Simple Expression Names">&sect;6.5.6.1</a>, <a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>).
            </p>
            <p class="norm-error"><a name="jls-9.3-320"></a>
               It is a compile-time error for the body of an interface declaration to
               declare two fields with the same name.
            </p>
            <p class="norm-static"><a name="jls-9.3-330"></a>
               If the interface declares a field with a certain name, then the
               declaration of that field is said to <span class="emphasis"><em>hide</em></span> any and
               all accessible declarations of fields with the same name in
               superinterfaces of the interface.
            </p>
            <p class="norm-error"><a name="jls-9.3-400"></a>
               It is possible for an interface to inherit more than one field with
               the same name. Such a situation does not in itself cause a
               compile-time error. However, any attempt within the body of the
               interface declaration to refer to any such field by its simple name
               will result in a compile-time error, because the reference is ambiguous.
            </p>
            <p class="norm-static"><a name="jls-9.3-410"></a>
               There might be several paths by which the same field declaration is
               inherited from an interface. In such a situation, the field is
               considered to be inherited only once, and it may be referred to by its
               simple name without ambiguity.
            </p>
            <div class="example"><a name="d5e17692"></a><p class="title"><b>Example&nbsp;9.3-1.&nbsp;Ambiguous Inherited Fields</b></p>
               <div class="example-contents">
                  <p class="note">If two fields with the same name are inherited by an
                     interface because, for example, two of its direct superinterfaces
                     declare fields with that name, then a single ambiguous member
                     results. Any use of this ambiguous member will result in a
                     compile-time error. In the program:
                  </p><pre class="programlisting">
interface BaseColors {
    int RED = 1, GREEN = 2, BLUE = 4;
}
interface RainbowColors extends BaseColors {
    int YELLOW = 3, ORANGE = 5, INDIGO = 6, VIOLET = 7;
}
interface PrintColors extends BaseColors {
    int YELLOW = 8, CYAN = 16, MAGENTA = 32;
}
interface LotsOfColors extends RainbowColors, PrintColors {
    int FUCHSIA = 17, VERMILION = 43, CHARTREUSE = RED+90;
}
</pre><p class="note">the interface <code class="literal">LotsOfColors</code>
                     inherits two fields named <code class="literal">YELLOW</code>. This is all right
                     as long as the interface does not contain any reference by simple name
                     to the field <code class="literal">YELLOW</code>. (Such a reference could occur
                     within a variable initializer for a field.)
                  </p>
                  <p class="note">Even if interface <code class="literal">PrintColors</code>
                     were to give the value <code class="literal">3</code>
                     to <code class="literal">YELLOW</code> rather than the
                     value <code class="literal">8</code>, a reference to
                     field <code class="literal">YELLOW</code> within
                     interface <code class="literal">LotsOfColors</code> would still be considered
                     ambiguous.
                  </p>
               </div>
            </div><br class="example-break"><div class="example"><a name="d5e17707"></a><p class="title"><b>Example&nbsp;9.3-2.&nbsp;Multiply Inherited Fields</b></p>
               <div class="example-contents">
                  <p class="note">If a single field is inherited multiple times from
                     the same interface because, for example, both this interface and one
                     of this interface's direct superinterfaces extend the interface that
                     declares the field, then only a single member results. This situation
                     does not in itself cause a compile-time error.
                  </p>
                  <p class="note">In the previous example, the
                     fields <code class="literal">RED</code>, <code class="literal">GREEN</code>,
                     and <code class="literal">BLUE</code> are inherited by
                     interface <code class="literal">LotsOfColors</code> in more than one way,
                     through interface <code class="literal">RainbowColors</code> and also through
                     interface <code class="literal">PrintColors</code>, but the reference to
                     field <code class="literal">RED</code> in
                     interface <code class="literal">LotsOfColors</code> is not considered ambiguous
                     because only one actual declaration of the
                     field <code class="literal">RED</code> is involved.
                  </p>
               </div>
            </div><br class="example-break"><div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.3.1"></a>9.3.1.&nbsp;Initialization of Fields in Interfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-9.3.1-100"></a>
                  Every declarator in a field declaration of an interface must have a
                  variable initializer, or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-9.3.1-110"></a>
                  The initializer need not be a constant expression
                  (<a class="xref" href="jls-15.html#jls-15.29" title="15.29.&nbsp;Constant Expressions">&sect;15.29</a>).
               </p>
               <p class="norm-error"><a name="jls-9.3.1-200"></a>
                  It is a compile-time error if the initializer of an interface field
                  uses the simple name of the same field or another field whose
                  declaration occurs  to the right of the
                  initializer (<a class="xref" href="jls-3.html#jls-3.5" title="3.5.&nbsp;Input Elements and Tokens">&sect;3.5</a>) in the same interface.
               </p>
               <p class="norm-error"><a name="jls-9.3.1-210"></a>
                  The initializer of an interface field may not refer to the current
                  object using the keyword <code class="literal">this</code> or the keyword <code class="literal">super</code>, as specified
                  in <a class="xref" href="jls-15.html#jls-15.8.3" title="15.8.3.&nbsp;this">&sect;15.8.3</a>, <a class="xref" href="jls-15.html#jls-15.11.2" title="15.11.2.&nbsp;Accessing Superclass Members using super">&sect;15.11.2</a>, and
                  <a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>.
               </p>
               <p class="norm-dynamic"><a name="jls-9.3.1-300"></a>
                  At run time, the initializer is evaluated and the field assignment
                  performed exactly once, when the interface is initialized (<a class="xref" href="jls-12.html#jls-12.4.2" title="12.4.2.&nbsp;Detailed Initialization Procedure">&sect;12.4.2</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-9.3.1-310"></a>
                  Note that interface fields that are constant variables (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>) are
                  initialized before other interface fields. This also applies to
                  <code class="literal">static</code> fields that are constant variables in classes (<a class="xref" href="jls-8.html#jls-8.3.2" title="8.3.2.&nbsp;Field Initialization">&sect;8.3.2</a>). Such fields  will
                  never be observed to have their default initial values (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>), even by devious programs.
               </p>
               <div class="example"><a name="d5e17740"></a><p class="title"><b>Example&nbsp;9.3.1-1.&nbsp;Forward Reference to a Field</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface Test {
    float f = j;
    int   j = 1;
    int   k = k + 1;
}
</pre><p class="note">This program causes two compile-time errors,
                        because <code class="literal">j</code> is referred to in the initialization
                        of <code class="literal">f</code> before <code class="literal">j</code> is declared, and
                        because the initialization of <code class="literal">k</code> refers
                        to <code class="literal">k</code> itself.
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-9.4"></a>9.4.&nbsp;Method Declarations
                     </h2>
                  </div>
               </div>
            </div>
            <div id="jls-9.4-100" class="productionset"><a name="jls-9.4-100"></a>
                 
               
                 
               <div class="production"><a name="jls-InterfaceMethodDeclaration"></a>
                      
                  <div class="lhs">InterfaceMethodDeclaration:</div>
                      
                  <div class="rhs">
                           {<a href="jls-9.html#jls-InterfaceMethodModifier" title="InterfaceMethodModifier">InterfaceMethodModifier</a>}
                           <a href="jls-8.html#jls-MethodHeader" title="MethodHeader">MethodHeader</a>
                           <a href="jls-8.html#jls-MethodBody" title="MethodBody">MethodBody</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-InterfaceMethodModifier"></a>
                      
                  <div class="lhs">InterfaceMethodModifier:</div>
                      
                  <div class="rhs">
                           (one of) <br>
                           <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a> <code class="literal">public</code> <code class="literal">private</code> <br>
                           <code class="literal">abstract</code> <code class="literal">default</code> <code class="literal">static</code> <code class="literal">strictfp</code>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="note">The following productions from
               <a class="xref" href="jls-8.html#jls-8.4" title="8.4.&nbsp;Method Declarations">&sect;8.4</a>, <a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Result">&sect;8.4.5</a>, and
               <a class="xref" href="jls-8.html#jls-8.4.7" title="8.4.7.&nbsp;Method Body">&sect;8.4.7</a> are shown here for convenience:
            </p>
            <div id="d5e17773" class="productionset"><a name="d5e17773"></a>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">MethodHeader:</div>
                         
                     <div class="rhs">
                              <a href="jls-8.html#jls-Result" title="Result">Result</a> <a href="jls-8.html#jls-MethodDeclarator" title="MethodDeclarator">MethodDeclarator</a> [<a href="jls-8.html#jls-Throws" title="Throws">Throws</a>] <br>
                        
                              <a href="jls-8.html#jls-TypeParameters" title="TypeParameters">TypeParameters</a> {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>}
                              <a href="jls-8.html#jls-Result" title="Result">Result</a> <a href="jls-8.html#jls-MethodDeclarator" title="MethodDeclarator">MethodDeclarator</a> [<a href="jls-8.html#jls-Throws" title="Throws">Throws</a>]
                            
                     </div>
                       
                  </div>
               </div>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">Result:</div>
                         
                     <div class="rhs">
                              <a href="jls-8.html#jls-UnannType" title="UnannType">UnannType</a> <br>
                              <code class="literal">void</code>
                            
                     </div>
                       
                  </div>
               </div>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">MethodDeclarator:</div>
                         
                     <div class="rhs">
                               <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                               <code class="literal">(</code> [<a href="jls-8.html#jls-ReceiverParameter" title="ReceiverParameter">ReceiverParameter</a> <code class="literal">,</code>] [<a href="jls-8.html#jls-FormalParameterList" title="FormalParameterList">FormalParameterList</a>] <code class="literal">)</code>
                               [<a href="jls-4.html#jls-Dims" title="Dims">Dims</a>]
                            
                     </div>
                       
                  </div>
               </div>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">MethodBody:</div>
                         
                     <div class="rhs">
                              <a href="jls-14.html#jls-Block" title="Block">Block</a> <br>
                              <code class="literal">;</code>
                            
                     </div>
                       
                  </div>
               </div>
               
            </div>
            <p class="norm-error"><a name="jls-9.4-110"></a>
               The rules concerning annotation modifiers for an interface method declaration
               are specified in <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a> and
               <a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Interface">&sect;9.7.5</a>.
            </p>
            <p class="norm-static"><a name="jls-9.4-120"></a>
               A method in the body of an interface declaration may be declared
               <code class="literal">public</code> or <code class="literal">private</code> (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>). If no access modifier
               is given, the method is implicitly <code class="literal">public</code>. It is permitted, but
               discouraged as a matter of style, to redundantly specify the <code class="literal">public</code>
               modifier for a method declaration in an interface declaration.
            </p>
            <p class="norm-static"><a name="jls-9.4-200"></a>
               
               A <span class="emphasis"><em>default method</em></span> is an instance method declared
               in an interface with the <code class="literal">default</code> modifier. Its body is always
               represented by a block, which provides a default implementation for
               any class that implements the interface without overriding the
               method. Default methods are distinct from concrete methods
               (<a class="xref" href="jls-8.html#jls-8.4.3.1" title="8.4.3.1.&nbsp;abstract Methods">&sect;8.4.3.1</a>), which are declared in classes, and
               from <code class="literal">private</code> interface methods, which are neither inherited nor
               overridden.
            </p>
            <p class="norm-static"><a name="jls-9.4-210"></a>
               An interface can declare <code class="literal">static</code> methods, which are invoked without
               reference to a particular object. <code class="literal">static</code> interface methods are
               distinct from default methods, <code class="literal">abstract</code> interface methods, and
               non-<code class="literal">static</code> <code class="literal">private</code> interface methods, all of which are instance
               methods.
            </p>
            <p class="norm-static"><a name="jls-9.4-220"></a>
               The declaration of a <code class="literal">static</code> interface method introduces a static
               context (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>), which limits the use of
               constructs that refer to the current object. Notably, the keywords
               <code class="literal">this</code> and <code class="literal">super</code> are prohibited in a static context (<a class="xref" href="jls-15.html#jls-15.8.3" title="15.8.3.&nbsp;this">&sect;15.8.3</a>, <a class="xref" href="jls-15.html#jls-15.11.2" title="15.11.2.&nbsp;Accessing Superclass Members using super">&sect;15.11.2</a>), as are
               unqualified references to instance variables, instance methods, and
               type parameters of lexically enclosing declarations (<a class="xref" href="jls-6.html#jls-6.5.5.1" title="6.5.5.1.&nbsp;Simple Type Names">&sect;6.5.5.1</a>, <a class="xref" href="jls-6.html#jls-6.5.6.1" title="6.5.6.1.&nbsp;Simple Expression Names">&sect;6.5.6.1</a>, <a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>).
            </p>
            <p class="norm-static"><a name="jls-9.4-230"></a>
               References to an instance method from a static context or a nested
               class or interface are restricted (<a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>).
            </p>
            <p class="norm-dynamic"><a name="jls-9.4-240"></a>
               
               The <code class="literal">strictfp</code> modifier on an interface method declaration is obsolete
               and should not be used in new code. Its presence or absence has no
               effect at run time.
            </p>
            <p class="norm-static"><a name="jls-9.4-250"></a>
               
               An interface method lacking a <code class="literal">private</code>, <code class="literal">default</code>, or <code class="literal">static</code>
               modifier is implicitly <code class="literal">abstract</code>. Its body is represented by a
               semicolon, not a block. It is permitted, but discouraged as a matter
               of style, to redundantly specify the <code class="literal">abstract</code> modifier for such a
               method declaration.
            </p>
            <p class="note">
               Note that an interface method may not be declared with <code class="literal">protected</code> or
               package access, or with the modifiers <code class="literal">final</code>, <code class="literal">synchronized</code>, or
               <code class="literal">native</code>.
            </p>
            <p class="norm-error"><a name="jls-9.4-300"></a>
               It is a compile-time error if the same keyword appears more than once
               as a modifier for an interface method declaration, or if an interface
               method declaration has more than one of the access modifiers <code class="literal">public</code>
               and <code class="literal">private</code> (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>).
            </p>
            <p class="norm-error"><a name="jls-9.4-310"></a>
               It is a compile-time error if an interface method declaration has
               more than one of the keywords <code class="literal">abstract</code>, <code class="literal">default</code>, or <code class="literal">static</code>.
            </p>
            <p class="norm-error"><a name="jls-9.4-320"></a>
               It is a compile-time error if an interface method declaration that
               contains the keyword <code class="literal">private</code> also contains the keyword <code class="literal">abstract</code> or
               <code class="literal">default</code>. It is permitted for an interface method declaration to
               contain both <code class="literal">private</code> and <code class="literal">static</code>.
            </p>
            <p class="norm-error"><a name="jls-9.4-330"></a>
               It is a compile-time error if an interface method declaration that
               contains the keyword <code class="literal">abstract</code> also contains the keyword <code class="literal">strictfp</code>.
            </p>
            <p class="norm-error"><a name="jls-9.4-400"></a>
               It is a compile-time error for the body of an interface declaration
               to declare, explicitly or implicitly, two methods with override-equivalent
               signatures (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>). However, an interface may
               inherit several <code class="literal">abstract</code> methods with such signatures
               (<a class="xref" href="jls-9.html#jls-9.4.1" title="9.4.1.&nbsp;Inheritance and Overriding">&sect;9.4.1</a>).
            </p>
            <p class="norm-static"><a name="jls-9.4-500"></a>
               A method declared in an interface may be generic. The rules for type
               parameters of a generic method in an interface are the same as for a
               generic method in a class (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>).
            </p>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.4.1"></a>9.4.1.&nbsp;Inheritance and Overriding
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.4.1-100"></a>
                  An interface <span class="type">I</span> <span class="emphasis"><em>inherits</em></span> from its direct
                  superinterface types all <code class="literal">abstract</code> and default methods <code class="varname">m</code>
                  for which all of the following are true:
               </p>
               <div class="norm">
                  <ul class="norm" style="list-style-type: disc; ">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.4.1-100-A"></a>
                                 <code class="varname">m</code> is a member of a direct superinterface type of <span class="type">I</span>, <span class="type">J</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.4.1-100-B"></a>
                                 No method declared in <span class="type">I</span> has a signature that is a subsignature
                                 (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) of the signature of <code class="varname">m</code>
                                 as a member of <span class="type">J</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.4.1-100-C"></a>
                                 There exists no method <code class="varname">m'</code> that is a member of a direct
                                 superinterface of <span class="type">I</span>, <span class="type">J'</span> (<code class="varname">m</code> distinct from <code class="varname">m'</code>, <span class="type">J</span>
                                 distinct from <span class="type">J'</span>), such that <code class="varname">m'</code> overrides from
                                 the interface of <span class="type">J'</span> the declaration of the method <code class="varname">m</code>
                                 (<a class="xref" href="jls-9.html#jls-9.4.1.1" title="9.4.1.1.&nbsp;Overriding (by Instance Methods)">&sect;9.4.1.1</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">Note that methods are overridden on a
                  signature-by-signature basis. If, for example, an interface declares
                  two <code class="literal">public</code> methods with the same name (<a class="xref" href="jls-9.html#jls-9.4.2" title="9.4.2.&nbsp;Overloading">&sect;9.4.2</a>),
                  and a subinterface overrides one of them, the subinterface still
                  inherits the other method.
               </p>
               <p class="note">
                  The third clause above prevents a subinterface from re-inheriting a
                  method that has already been overridden by another of its
                  superinterfaces. For example, in this program:
               </p><pre class="screen">
interface Top {
    default String name() { return "unnamed"; }
}
interface Left extends Top {
    default String name() { return getClass().getName(); }
}
interface Right extends Top {}

interface Bottom extends Left, Right {}
</pre><p class="note">
                  <code class="literal">Right</code> inherits <code class="literal">name()</code>
                  from <code class="literal">Top</code>, but <code class="literal">Bottom</code>
                  inherits <code class="literal">name()</code> from
                  <code class="literal">Left</code>, not <code class="literal">Right</code>. This is
                  because <code class="literal">name()</code> from <code class="literal">Left</code>
                  overrides the declaration of <code class="literal">name()</code>
                  in <code class="literal">Top</code>.
               </p>
               <p class="norm-static"><a name="jls-9.4.1-200"></a>
                  
                  An interface does not inherit <code class="literal">private</code> or <code class="literal">static</code> methods from its
                  superinterfaces.
               </p>
               <p class="norm-error"><a name="jls-9.4.1-210"></a>
                  
                  If an interface <span class="type">I</span> declares a <code class="literal">private</code> or <code class="literal">static</code> method <code class="varname">m</code>, and
                  the signature of <code class="varname">m</code> is a subsignature of a <code class="literal">public</code> instance method
                  <code class="varname">m'</code> in a superinterface type of <span class="type">I</span>, and <code class="varname">m'</code> would otherwise be
                  accessible to code in <span class="type">I</span>, then a compile-time error occurs.
               </p>
               <p class="note">
                  
                  In essence, a <code class="literal">static</code> method in an interface cannot hide an instance
                  method in a superinterface type. This is similar to the rule in
                  <a class="xref" href="jls-8.html#jls-8.4.8.2" title="8.4.8.2.&nbsp;Hiding (by Class Methods)">&sect;8.4.8.2</a> whereby a <code class="literal">static</code> method in a class
                  cannot hide an instance method in a superclass type or superinterface type.
                  Note that the rule in <a class="xref" href="jls-8.html#jls-8.4.8.2" title="8.4.8.2.&nbsp;Hiding (by Class Methods)">&sect;8.4.8.2</a> speaks of a class that
                  "declares or inherits a <code class="literal">static</code> method", whereas the rule above
                  speaks only of an interface that "declares a <code class="literal">static</code> method", since
                  an interface cannot inherit a <code class="literal">static</code> method. Also note that the rule
                  in <a class="xref" href="jls-8.html#jls-8.4.8.2" title="8.4.8.2.&nbsp;Hiding (by Class Methods)">&sect;8.4.8.2</a> allows hiding of both instance and
                  <code class="literal">static</code> methods in superclasses/superinterfaces, whereas the rule
                  above considers only <code class="literal">public</code> instance methods in superinterface types.
               </p>
               <p class="note">
                  Along the same lines, a <code class="literal">private</code> method in an interface cannot
                  override an instance method - whether <code class="literal">public</code> or <code class="literal">private</code> - in a
                  superinterface type. This is similar to the rules in
                  <a class="xref" href="jls-8.html#jls-8.4.8.1" title="8.4.8.1.&nbsp;Overriding (by Instance Methods)">&sect;8.4.8.1</a> and <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>
                  whereby a <code class="literal">private</code> method in a class cannot override any instance
                  method in a superclass type or superinterface type, because
                  <a class="xref" href="jls-8.html#jls-8.4.8.1" title="8.4.8.1.&nbsp;Overriding (by Instance Methods)">&sect;8.4.8.1</a> requires the overridden method to be
                  non-<code class="literal">private</code> and <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a> requires the
                  overriding method to provide at least as much access as the overridden
                  method. In summary, only <code class="literal">public</code> methods in interfaces can be
                  overridden, and only by <code class="literal">public</code> methods in subinterfaces or in
                  implementing classes.
               </p>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.4.1.1"></a>9.4.1.1.&nbsp;Overriding (by Instance Methods)
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-9.4.1.1-100"></a>
                     An instance method <code class="varname">m<sub>I</sub></code> declared in or inherited by interface
                     <span class="type">I</span>, <span class="emphasis"><em>overrides from <span class="type">I</span></em></span> another instance method
                     <code class="varname">m<sub>J</sub></code> declared in interface <span class="type">J</span>, iff all of the following are true:
                  </p>
                  <div class="norm">
                     <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.4.1.1-100-A"></a>
                                    <span class="type">I</span> is a subinterface of <span class="type">J</span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.4.1.1-100-B"></a>
                                    <span class="type">I</span> does not inherit <code class="varname">m<sub>J</sub></code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.4.1.1-100-C"></a>
                                    The signature of <code class="varname">m<sub>I</sub></code> is a subsignature
                                    (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) of the signature of <code class="varname">m<sub>J</sub></code>
                                    as a member of the supertype of <span class="type">I</span> that names <span class="type">J</span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.4.1.1-100-D"></a>
                                    <code class="varname">m<sub>J</sub></code> is <code class="literal">public</code>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-9.4.1.1-200"></a>
                     The presence or absence of the <code class="literal">strictfp</code> modifier has absolutely no
                     effect on the rules for overriding methods. For example, it is
                     permitted for a method that is not <code class="literal">strictfp</code> to override a <code class="literal">strictfp</code>
                     method, and it is permitted for a <code class="literal">strictfp</code> method to override a
                     method that is not <code class="literal">strictfp</code>.
                  </p>
                  <p class="note">
                     An overridden default method can be accessed by using a method
                     invocation expression (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>) that contains the
                     keyword <code class="literal">super</code> qualified by a superinterface name.
                  </p>
               </div>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.4.1.2"></a>9.4.1.2.&nbsp;Requirements in Overriding
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-9.4.1.2-100"></a>
                     The relationship between the return type of an interface method and
                     the return types of any overridden interface methods is specified in
                     <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>.
                  </p>
                  <p class="norm-static"><a name="jls-9.4.1.2-200"></a>
                     The relationship between the <code class="literal">throws</code> clause of an interface method
                     and the <code class="literal">throws</code> clauses of any overridden interface methods is
                     specified in <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>.
                  </p>
                  <p class="norm-static"><a name="jls-9.4.1.2-300"></a>
                     The relationship between the signature of an interface method and the
                     signatures of any overridden interface methods is specified in
                     <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>.
                  </p>
                  <p class="norm-static"><a name="jls-9.4.1.2-350"></a>
                     The relationship between the accessibility of an interface method and
                     the accessibility of any overridden interface methods is specified in
                     <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>.
                  </p>
                  <p class="norm-error"><a name="jls-9.4.1.2-400"></a>
                     It is a compile-time error if a default method is override-equivalent
                     (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) with a non-<code class="literal">private</code> method of the class
                     <code class="literal">Object</code>, because any class implementing the interface will inherit
                     its own implementation of the method.
                  </p>
                  <p class="note">
                     The prohibition against declaring one of the <code class="literal">Object</code> methods as a
                     default method may be surprising. There are, after all, cases
                     like <code class="literal">java.util.List</code> in which the behavior
                     of <code class="literal">toString</code> and <code class="literal">equals</code> are
                     precisely defined. The motivation becomes clearer, however, when some
                     broader design decisions are understood:
                  </p>
                  <div class="note">
                     <ul class="note" style="list-style-type: disc; ">
                        <li class="listitem">
                           <p class="note">First, methods inherited from a superclass are
                                    allowed to override methods inherited from superinterfaces
                                    (<a class="xref" href="jls-8.html#jls-8.4.8.1" title="8.4.8.1.&nbsp;Overriding (by Instance Methods)">&sect;8.4.8.1</a>). So, every implementing class
                                    would automatically override an interface's 
                                    <code class="literal">toString</code> default. This is longstanding
                                    behavior in the Java programming language. It is not something we wish to
                                    change with the design of default methods, because that would
                                    conflict with the goal of allowing interfaces to unobtrusively
                                    evolve, only providing default behavior when a class doesn't
                                    already have it through the class hierarchy.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">Second, interfaces do <span class="emphasis"><em>not</em></span>
                                    inherit from <code class="literal">Object</code>, but rather implicitly declare many of the
                                    same methods as <code class="literal">Object</code> (<a class="xref" href="jls-9.html#jls-9.2" title="9.2.&nbsp;Interface Members">&sect;9.2</a>). So, there
                                    is no common ancestor for the <code class="literal">toString</code>
                                    declared in <code class="literal">Object</code> and the <code class="literal">toString</code>
                                    declared in an interface. At best, if both were candidates for
                                    inheritance by a class, they would conflict. Working around this
                                    problem would require awkward commingling of the class and
                                    interface inheritance trees.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">Third, use cases for declaring <code class="literal">Object</code> methods
                                    in interfaces typically assume a linear interface hierarchy; the
                                    feature does not generalize very well to multiple inheritance
                                    scenarios.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">Fourth, the <code class="literal">Object</code> methods are so fundamental
                                    that it seems dangerous to allow an arbitrary superinterface to
                                    silently add a default method that changes their
                                    behavior.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="note">
                     An interface is free, however, to define another method that provides
                     behavior useful for classes that override the <code class="literal">Object</code> methods. For
                     example, the <code class="literal">java.util.List</code> interface could declare
                     an <code class="literal">elementString</code> method that produces the string
                     described by the contract of <code class="literal">toString</code>; implementors
                     of <code class="literal">toString</code> in classes could then delegate to this
                     method.
                  </p>
               </div>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.4.1.3"></a>9.4.1.3.&nbsp;Inheriting Methods with Override-Equivalent Signatures
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-9.4.1.3-100"></a>It is
                     possible for an interface to inherit several methods with
                     override-equivalent signatures (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>).
                  </p>
                  <p class="norm-error"><a name="jls-9.4.1.3-110"></a>If an interface
                     <span class="type">I</span> inherits a default method whose signature is override-equivalent
                     with another method inherited by <span class="type">I</span>, then a compile-time error
                     occurs. (This is the case whether the other method is <code class="literal">abstract</code> or
                     <code class="literal">default</code>.)
                  </p>
                  <p class="norm-static"><a name="jls-9.4.1.3-120"></a>Otherwise, all
                     the inherited methods are <code class="literal">abstract</code>, and the interface is considered
                     to inherit all the methods.
                  </p>
                  <p class="norm-error"><a name="jls-9.4.1.3-200"></a>One of
                     the inherited methods must be return-type-substitutable for every
                     other inherited method, or else a compile-time error occurs. (The
                     <code class="literal">throws</code> clauses do not cause errors in this case.)
                  </p>
                  <p class="norm-static"><a name="jls-9.4.1.3-300"></a>There
                     might be several paths by which the same method declaration is
                     inherited from an interface. This fact causes no difficulty and never,
                     of itself, results in a compile-time error.
                  </p>
                  <p class="note">
                     Naturally, when two different default methods with matching signatures
                     are inherited by a subinterface, there is a behavioral conflict. We
                     actively detect this conflict and notify the programmer with an error,
                     rather than waiting for the problem to arise when a concrete class is
                     compiled. The error can be avoided by declaring a new method that
                     overrides, and thus prevents the inheritance of, all conflicting
                     methods.
                  </p>
                  <p class="note">
                     Similarly, when an <code class="literal">abstract</code> method and a <code class="literal">default</code> method with matching
                     signatures are inherited by a subinterface, we produce an error. In
                     this case, it would be possible to give priority to one or the other -
                     perhaps we would assume that the default method provides a reasonable
                     implementation for the <code class="literal">abstract</code> method. But this is risky, since other
                     than the coincidental name and signature, we have no reason to believe
                     that the default method behaves consistently with the <code class="literal">abstract</code>
                     method's contract - the default method may not have even existed when
                     the subinterface was originally developed. It is safer in this
                     situation to ask the user to actively assert that the default
                     implementation is appropriate (via an overriding declaration).
                  </p>
                  <p class="note">
                     In contrast, the longstanding behavior for inherited concrete methods
                     in classes is that they override <code class="literal">abstract</code> methods declared in
                     interfaces (see <a class="xref" href="jls-8.html#jls-8.4.8" title="8.4.8.&nbsp;Inheritance, Overriding, and Hiding">&sect;8.4.8</a>). The same argument about
                     potential contract violation applies here, but in this case there is
                     an inherent imbalance between classes and interfaces.  We prefer, in
                     order to preserve the independent nature of class hierarchies, to
                     minimize class-interface clashes by simply giving priority to concrete
                     methods.
                  </p>
               </div>
            </div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.4.2"></a>9.4.2.&nbsp;Overloading
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.4.2-100"></a>If two
                  methods of an interface (whether both declared in the same interface,
                  or both inherited by an interface, or one declared and one inherited)
                  have the same name but different signatures that are not
                  override-equivalent (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>), then the method
                  name is said to be <span class="emphasis"><em>overloaded</em></span>.
               </p>
               <p class="norm"><a name="jls-9.4.2-110"></a>This fact causes no
                  difficulty and never of itself results in a compile-time error. There
                  is no required relationship between the return types or between the
                  <code class="literal">throws</code> clauses of two methods with the same name but different
                  signatures that are not override-equivalent.
               </p>
               <div class="example"><a name="d5e18058"></a><p class="title"><b>Example&nbsp;9.4.2-1.&nbsp;Overloading an <code class="literal">abstract</code> Method Declaration</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface PointInterface {
    void move(int dx, int dy);
}
interface RealPointInterface extends PointInterface {
    void move(float dx, float dy);
    void move(double dx, double dy);
}
</pre><p class="note">Here, the method named <code class="literal">move</code> is
                        overloaded in interface <code class="literal">RealPointInterface</code> with
                        three different signatures, two of them declared and one
                        inherited. Any non-<code class="literal">abstract</code> class that implements
                        interface <code class="literal">RealPointInterface</code> must provide
                        implementations of all three method signatures.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.4.3"></a>9.4.3.&nbsp;Interface Method Body
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-9.4.3-100"></a>
                  A default method has a block body. This block of code provides an
                  implementation of the method in the event that a class implements the
                  interface but does not provide its own implementation of the
                  method.
               </p>
               <p class="norm"><a name="jls-9.4.3-110"></a>
                  A <code class="literal">private</code> or <code class="literal">static</code> interface method also has a block body,
                  which provides the implementation of the method.
               </p>
               <p class="norm-error"><a name="jls-9.4.3-200"></a>
                  It is a compile-time error if an interface method declaration is
                  <code class="literal">abstract</code> (explicitly or implicitly) and has a block for its
                  body.
               </p>
               <p class="norm-error"><a name="jls-9.4.3-210"></a>
                  It is a compile-time error if an interface method declaration is
                  <code class="literal">default</code>, <code class="literal">private</code>, or <code class="literal">static</code>, and has a semicolon for its
                  body.
               </p>
               <p class="norm-error"><a name="jls-9.4.3-310"></a>
                  The rules for <code class="literal">return</code> statements in a method body are specified in
                  <a class="xref" href="jls-14.html#jls-14.17" title="14.17.&nbsp;The return Statement">&sect;14.17</a>.
               </p>
               <p class="norm-error"><a name="jls-9.4.3-320"></a>
                  If a method is declared to have a return type (<a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Result">&sect;8.4.5</a>), 
                  then a compile-time error occurs if the body of the method can complete
                  normally (<a class="xref" href="jls-14.html#jls-14.1" title="14.1.&nbsp;Normal and Abrupt Completion of Statements">&sect;14.1</a>).
               </p>
            </div>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-9.5"></a>9.5.&nbsp;Member Class and Interface Declarations
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-9.5-100"></a>
               An interface body (<a class="xref" href="jls-9.html#jls-9.1.5" title="9.1.5.&nbsp;Interface Body and Member Declarations">&sect;9.1.5</a>) may contain declarations
               of member classes and member interfaces (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Class and Interface Declarations">&sect;8.5</a>).
            </p>
            <p class="norm-static"><a name="jls-9.5-110"></a>
               Every member class or interface declaration in the body of an
               interface declaration is implicitly <code class="literal">public</code> and <code class="literal">static</code> (<a class="xref" href="jls-9.html#jls-9.1.1.3" title="9.1.1.3.&nbsp;static Interfaces">&sect;9.1.1.3</a>). It is permitted to redundantly specify
               either or both of these modifiers.
            </p>
            <p class="norm-error"><a name="jls-9.5-120"></a>
               It is a compile-time error if a member class or interface declaration in an
               interface has the modifier <code class="literal">protected</code> or <code class="literal">private</code>.
            </p>
            <p class="norm-error"><a name="jls-9.5-130"></a>
               The rules for modifiers of a member class declaration in the body of
               an interface declaration are specified in
               <a class="xref" href="jls-8.html#jls-8.1.1" title="8.1.1.&nbsp;Class Modifiers">&sect;8.1.1</a>.
            </p>
            <p class="norm-error"><a name="jls-9.5-140"></a>
               The rules for modifiers of a member interface declaration in the body
               of an interface declaration are specified in
               <a class="xref" href="jls-9.html#jls-9.1.1" title="9.1.1.&nbsp;Interface Modifiers">&sect;9.1.1</a>.
            </p>
            <p class="norm-static"><a name="jls-9.5-200"></a>
               If an interface declares a member class or interface with a certain
               name, then the declaration of the member class or interface is said to
               <span class="emphasis"><em>hide</em></span> any and all accessible declarations of
               member classes and interface with the same name in superinterfaces of
               the interface.
            </p>
            <p class="norm-static"><a name="jls-9.5-300"></a>
               An interface inherits from its direct superinterfaces all the
               member classes and interfaces of the direct superinterfaces
               that are not hidden by a declaration in the interface.
            </p>
            <p class="norm-error"><a name="jls-9.5-310"></a>
               It is possible for an interface to inherit more than one member class
               or interface with the same name. Such a situation does not in itself
               cause a compile-time error. However, any attempt within the body of
               the interface to refer to any such member class or interface by its
               simple name will result in a compile-time error, because the reference
               is ambiguous.
            </p>
            <p class="norm-static"><a name="jls-9.5-320"></a>
               There might be several paths by which the same member class or
               interface declaration is inherited from an interface. In such a situation,
               the member class or interface is considered to be inherited only once,
               and it may be referred to by its simple name without ambiguity.
            </p>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-9.6"></a>9.6.&nbsp;Annotation Interfaces
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-9.6-100"></a>
               An <span class="emphasis"><em>annotation interface declaration</em></span> specifies an
               <span class="emphasis"><em>annotation interface</em></span>, a specialized kind of
               interface.  To distinguish an annotation interface declaration from a
               normal interface declaration, the keyword <code class="literal">interface</code> is preceded by
               an at sign (<code class="literal">@</code>).
            </p>
            <div id="jls-9.6-110" class="productionset"><a name="jls-9.6-110"></a>
                 
               <div class="production"><a name="jls-AnnotationInterfaceDeclaration"></a>
                      
                  <div class="lhs">AnnotationInterfaceDeclaration:</div>
                      
                  <div class="rhs">
                           {<a href="jls-9.html#jls-InterfaceModifier" title="InterfaceModifier">InterfaceModifier</a>}
                           <code class="literal">@</code> <code class="literal">interface</code> <a href="jls-3.html#jls-TypeIdentifier" title="TypeIdentifier">TypeIdentifier</a>
                           <a href="jls-9.html#jls-AnnotationInterfaceBody" title="AnnotationInterfaceBody">AnnotationInterfaceBody</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="note">Note that the at sign (<code class="literal">@</code>) and the keyword
               <code class="literal">interface</code> are distinct tokens. It is possible to separate them with
               whitespace, but this is discouraged as a matter of style.
            </p>
            <p class="norm-static"><a name="jls-9.6-200"></a>
               Unless explicitly modified in this section and its subsections, all of
               the rules that apply to normal interface declarations (<a class="xref" href="jls-9.html#jls-9.1" title="9.1.&nbsp;Interface Declarations">&sect;9.1</a>) apply to annotation interface declarations.
            </p>
            <p class="note">For example, annotation interface declarations have
               the same rules for scope as normal interface declarations.
            </p>
            <p class="norm-static"><a name="jls-9.6-210"></a>
               It is a compile-time error if an annotation interface declaration has
               the modifier <code class="literal">sealed</code> or <code class="literal">non-sealed</code> (<a class="xref" href="jls-9.html#jls-9.1.1.4" title="9.1.1.4.&nbsp;sealed and non-sealed Interfaces">&sect;9.1.1.4</a>).
            </p>
            <p class="norm-static"><a name="jls-9.6-220"></a>
               An annotation interface declaration may specify a top level interface
               or a member interface, but not a local interface (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class and Interface Declarations">&sect;14.3</a>).
            </p>
            <p class="note">
               An annotation interface declaration is not permitted syntactically to
               appear within a block, by virtue of the
               <span class="emphasis"><em>LocalClassOrInterfaceDeclaration</em></span> production in
               <a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class and Interface Declarations">&sect;14.3</a>.
            </p>
            <p class="norm-error"><a name="jls-9.6-230"></a>
               It is a compile-time error if an annotation interface declaration
               
               appears directly or indirectly in the body of a local class, local
               interface, or anonymous class declaration (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class and Interface Declarations">&sect;14.3</a>,
               <a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>).
            </p>
            <p class="note">
               This rule, together with the syntactic restriction on annotation
               interface declarations noted above, ensures that an annotation
               interface always has a canonical name (<a class="xref" href="jls-6.html#jls-6.7" title="6.7.&nbsp;Fully Qualified Names and Canonical Names">&sect;6.7</a>).
               Having such a name is important because the purpose of an annotation
               interface is to be used by annotations in other compilation units.
               Since a local class or interface does not have a canonical name, an
               annotation interface declared anywhere within its syntactic body (if
               that were allowed) would not have a canonical name either.
            </p>
            <p class="note">
               The following code shows the effect of this rule and the related
               syntactic restriction:
            </p><pre class="programlisting">
class C {
    @interface A1 {}  /* Legal: an annotation interface can be a
                         member interface */

    void m() {
        @interface A2 {}  /* Illegal: an annotation interface cannot
                             be a local interface */

        class D {
            @interface A3 {}  /* Illegal: an annotation interface
                                 cannot be specified anywhere within
                                 the body of local class D */

            class E {
                @interface A4 {}
                  /* Illegal: an annotation interface cannot be
                     specified anywhere within the body of local class
                     D, even as a member of a class E nested in D */
            }
        }
    }
}

</pre><p class="norm-static"><a name="jls-9.6-240"></a>
               An annotation interface is never generic (<a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>).
            </p>
            <p class="note">Unlike a normal interface declaration, an annotation
               interface declaration cannot declare any type variables, by virtue of
               the <span class="emphasis"><em>AnnotationTypeDeclaration</em></span> production.
            </p>
            <p class="norm-static"><a name="jls-9.6-300"></a>
               The direct superinterface type of an annotation interface is always
               <code class="literal">java.lang.annotation.Annotation</code> (<a class="xref" href="jls-9.html#jls-9.1.3" title="9.1.3.&nbsp;Superinterfaces and Subinterfaces">&sect;9.1.3</a>).
            </p>
            <p class="note">Unlike a normal interface declaration, an annotation
               interface declaration cannot choose the direct superinterface type via
               an <code class="literal">extends</code> clause, by virtue of the
               <span class="emphasis"><em>AnnotationTypeDeclaration</em></span> production.
            </p>
            <p class="note">A consequence of the fact that an annotation
               interface declaration does not explicitly specify a superinterface
               type via <code class="literal">extends</code> is that a subinterface of an annotation interface
               is never itself an annotation interface, since the subinterface's
               declaration necessarily uses an <code class="literal">extends</code> clause. Similarly,
               <code class="literal">java.lang.annotation.Annotation</code> is not itself an annotation interface.
            </p>
            <p class="norm-static"><a name="jls-9.6-310"></a>
               An annotation interface inherits several methods from <code class="literal">java.lang.annotation.Annotation</code>,
               including the implicitly declared methods corresponding to the
               instance methods of <code class="literal">Object</code> (<a class="xref" href="jls-9.html#jls-9.2" title="9.2.&nbsp;Interface Members">&sect;9.2</a>), yet these
               methods do not define elements of the annotation interface (<a class="xref" href="jls-9.html#jls-9.6.1" title="9.6.1.&nbsp;Annotation Interface Elements">&sect;9.6.1</a>).
            </p>
            <p class="note">Because these methods do not define elements of the
               annotation interface, it is illegal to use them in annotations
               conforming to the annotation interface (<a class="xref" href="jls-9.html#jls-9.7" title="9.7.&nbsp;Annotations">&sect;9.7</a>).
               Without this rule, we could not ensure that elements were of the types
               representable in annotations, or that accessor methods for them would
               be available.
            </p>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.6.1"></a>9.6.1.&nbsp;Annotation Interface Elements
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.6.1-100"></a>
                  The body of an annotation interface declaration may contain method
                  declarations, each of which defines an <span class="emphasis"><em>element</em></span> of
                  the annotation interface. An annotation interface has no elements
                  other than those defined by the methods declared explicitly in the
                  annotation interface declaration.
               </p>
               <div id="jls-9.6.1-120" class="productionset"><a name="jls-9.6.1-120"></a>
                    
                  <div class="production"><a name="jls-AnnotationInterfaceBody"></a>
                         
                     <div class="lhs">AnnotationInterfaceBody:</div>
                         
                     <div class="rhs">
                              <code class="literal">{</code>
                              {<a href="jls-9.html#jls-AnnotationInterfaceMemberDeclaration" title="AnnotationInterfaceMemberDeclaration">AnnotationInterfaceMemberDeclaration</a>}
                              <code class="literal">}</code>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-AnnotationInterfaceMemberDeclaration"></a>
                         
                     <div class="lhs">AnnotationInterfaceMemberDeclaration:</div>
                         
                     <div class="rhs">
                              <a href="jls-9.html#jls-AnnotationInterfaceElementDeclaration" title="AnnotationInterfaceElementDeclaration">AnnotationInterfaceElementDeclaration</a> <br>
                              <a href="jls-9.html#jls-ConstantDeclaration" title="ConstantDeclaration">ConstantDeclaration</a> <br>
                              <a href="jls-8.html#jls-ClassDeclaration" title="ClassDeclaration">ClassDeclaration</a> <br>
                              <a href="jls-9.html#jls-InterfaceDeclaration" title="InterfaceDeclaration">InterfaceDeclaration</a> <br>
                              <code class="literal">;</code>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-AnnotationInterfaceElementDeclaration"></a>
                         
                     <div class="lhs">AnnotationInterfaceElementDeclaration:</div>
                         
                     <div class="rhs">
                              {<a href="jls-9.html#jls-AnnotationInterfaceElementModifier" title="AnnotationInterfaceElementModifier">AnnotationInterfaceElementModifier</a>}
                              <a href="jls-8.html#jls-UnannType" title="UnannType">UnannType</a> <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> 
                              <code class="literal">(</code> <code class="literal">)</code> [<a href="jls-4.html#jls-Dims" title="Dims">Dims</a>]
                              
                              [<a href="jls-9.html#jls-DefaultValue" title="DefaultValue">DefaultValue</a>] <code class="literal">;</code>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-AnnotationInterfaceElementModifier"></a>
                         
                     <div class="lhs">AnnotationInterfaceElementModifier:</div>
                         
                     <div class="rhs">
                              (one of) <br>
                              <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a> <code class="literal">public</code> <br>
                              <code class="literal">abstract</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="note">The following production from <a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>
                  is shown here for convenience:
               </p>
               <div id="d5e18205" class="productionset"><a name="d5e18205"></a>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">Dims:</div>
                            
                        <div class="rhs">
                                 {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code> {{<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code>}
                               
                        </div>
                          
                     </div>
                  </div>
                  
               </div>
               <p class="note">By virtue of the grammar above, a method declaration
                  in an annotation interface declaration cannot have formal parameters,
                  type parameters, or a <code class="literal">throws</code> clause; and cannot be <code class="literal">private</code>,
                  <code class="literal">default</code>, or <code class="literal">static</code>. Thus, an annotation interface cannot have the
                  same variety of methods as a normal interface. Note that it is still
                  possible for an annotation interface to inherit a default method from
                  its implicit superinterface, <code class="literal">java.lang.annotation.Annotation</code>, though no such default
                  method exists as of Java SE 17.
               </p>
               <p class="note">By convention, the only modifiers that should be
                  present on the declaration of an annotation interface element are
                  annotations.
               </p>
               <p class="norm-error"><a name="jls-9.6.1-200"></a>
                  The return type of a method declared in the body of annotation interface
                  must be one of the following, or a compile-time error occurs:
               </p>
               <div class="norm">
                  <ul class="norm" style="list-style-type: disc; ">
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.6.1-200-A"></a>
                                 A primitive type
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.6.1-200-B"></a>
                                 <code class="literal">String</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.6.1-200-C"></a>
                                 <code class="literal">Class</code> or an invocation of <code class="literal">Class</code> (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.6.1-200-D"></a>
                                 An enum class type
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.6.1-200-E"></a>
                                 An annotation interface type
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.6.1-200-F"></a>
                                 An array type whose component type is one of the preceding types
                                 (<a class="xref" href="jls-10.html#jls-10.1" title="10.1.&nbsp;Array Types">&sect;10.1</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="informalexample">
                  <p class="note">This rule precludes elements with nested array
                     types, such as:
                  </p><pre class="programlisting">
@interface Verboten {
    String[][] value();
}
</pre></div>
               <p class="norm-static"><a name="jls-9.6.1-210"></a>
                  The declaration of a method that returns an array is allowed to place
                  the bracket pair that denotes the array type after the empty formal
                  parameter list. This syntax is supported for compatibility with early
                  versions of the Java programming language. It is very strongly recommended that this
                  syntax is not used in new code.
               </p>
               <p class="norm-error"><a name="jls-9.6.1-220"></a>
                  It is a compile-time error if any method declared in an annotation
                  interface has a signature that is override-equivalent
                  (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) to that of any <code class="literal">public</code> or <code class="literal">protected</code>
                  method declared in class <code class="literal">Object</code> or in interface <code class="literal">java.lang.annotation.Annotation</code>.
               </p>
               <p class="norm-error"><a name="jls-9.6.1-230"></a>
                  It is a compile-time error if the declaration of an annotation interface
                  <span class="type">T</span> contains an element of type <span class="type">T</span>, either directly or indirectly.
               </p>
               <div class="informalexample">
                  <p class="note">For example, this is illegal:</p><pre class="programlisting">
@interface SelfRef { SelfRef value(); }
</pre><p class="note">and so is this:</p><pre class="programlisting">
@interface Ping { Pong value(); }
@interface Pong { Ping value(); }
</pre></div>
               <p class="norm-static"><a name="jls-9.6.1-300"></a>
                  An annotation interface with no elements is called a <span class="emphasis"><em>marker
                        annotation interface</em></span>.
               </p>
               <p class="norm-static"><a name="jls-9.6.1-310"></a>
                  An annotation interface with one element is called
                  a <span class="emphasis"><em>single-element annotation interface</em></span>.
               </p>
               <p class="norm-static"><a name="jls-9.6.1-320"></a>
                  By convention, the name of the sole element in a single-element
                  annotation interface is <code class="literal">value</code>. Linguistic support for this convention is
                  provided by single-element annotations (<a class="xref" href="jls-9.html#jls-9.7.3" title="9.7.3.&nbsp;Single-Element Annotations">&sect;9.7.3</a>).
               </p>
               <div class="example"><a name="d5e18258"></a><p class="title"><b>Example&nbsp;9.6.1-1.&nbsp;Annotation Interface Declaration</b></p>
                  <div class="example-contents">
                     <p class="note">The following annotation interface declaration defines an
                        annotation interface with several elements:
                     </p><pre class="programlisting">
/**
 * Describes the "request-for-enhancement" (RFE)
 * that led to the presence of the annotated API element.
 */
@interface RequestForEnhancement {
    int    id();        // Unique ID number associated with RFE
    String synopsis();  // Synopsis of RFE
    String engineer();  // Name of engineer who implemented RFE
    String date();      // Date RFE was implemented
}
</pre></div>
               </div><br class="example-break"><div class="example"><a name="d5e18262"></a><p class="title"><b>Example&nbsp;9.6.1-2.&nbsp;Marker Annotation Interface Declaration</b></p>
                  <div class="example-contents">
                     <p class="note">The following annotation interface declaration defines a
                        marker annotation interface:
                     </p><pre class="programlisting">
/**
 * An annotation with this type indicates that the 
 * specification of the annotated API element is 
 * preliminary and subject to change.
 */
@interface Preliminary {}
</pre></div>
               </div><br class="example-break"><div class="example"><a name="d5e18266"></a><p class="title"><b>Example&nbsp;9.6.1-3.&nbsp;Single-Element Annotation Interface Declarations</b></p>
                  <div class="example-contents">
                     <p class="note">The convention that a single-element annotation 
                        interface defines an element called <code class="literal">value</code> is illustrated in the
                        following annotation interface declaration:
                     </p><pre class="programlisting">
/**
 * Associates a copyright notice with the annotated API element.
 */
@interface Copyright {
    String value();
}
</pre><p class="note">The following annotation interface declaration defines
                        a single-element annotation interface whose sole element has an array
                        type:
                     </p><pre class="programlisting">
/**
 * Associates a list of endorsers with the annotated class.
 */
@interface Endorsers {
    String[] value();
}
</pre><p class="note">The following annotation interface declaration shows a
                        <code class="literal">Class</code>-typed element whose value is constrained by a bounded wildcard:
                     </p><pre class="programlisting">
interface Formatter {}

// Designates a formatter to pretty-print the annotated class
@interface PrettyPrinter {
    Class&lt;? extends Formatter&gt; value();
}
</pre><p class="note">The following annotation interface declaration contains
                        an element whose type is an annotation interface type:
                     </p><pre class="programlisting">
/**
 * Indicates the author of the annotated program element.
 */
@interface Author {
    Name value();
}
/**
 * A person's name.  This annotation interface is not 
 * designed to be used directly to annotate program elements, 
 * but to define elements of other annotation interfaces.
 */
@interface Name {
    String first();
    String last();
}

</pre><p class="note">The grammar for annotation interface declarations permits
                        other member declarations besides method declarations. For example,
                        one might choose to declare a nested enum class for use by an element
                        of the annotation interface:
                     </p><pre class="programlisting">
@interface Quality {
    enum Level { BAD, INDIFFERENT, GOOD }
    Level value();
}
</pre></div>
               </div><br class="example-break"></div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.6.2"></a>9.6.2.&nbsp;Defaults for Annotation Interface Elements
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.6.2-100"></a>
                  An annotation interface element may have a <span class="emphasis"><em>default
                        value</em></span>, specified by attaching the keyword <code class="literal">default</code> and a
                  value to the method declaration which defines the element.
               </p>
               <div id="jls-9.6.2-110" class="productionset"><a name="jls-9.6.2-110"></a>
                    
                  <div class="production"><a name="jls-DefaultValue"></a>
                         
                     <div class="lhs">DefaultValue:</div>
                         
                     <div class="rhs">
                              <code class="literal">default</code> <a href="jls-9.html#jls-ElementValue" title="ElementValue">ElementValue</a>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="note">The following productions from <a class="xref" href="jls-9.html#jls-9.7.1" title="9.7.1.&nbsp;Normal Annotations">&sect;9.7.1</a>
                  are shown here for convenience:
               </p>
               <div id="d5e18293" class="productionset"><a name="d5e18293"></a>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">ElementValue:</div>
                            
                        <div class="rhs">
                                 <a href="jls-15.html#jls-ConditionalExpression" title="ConditionalExpression">ConditionalExpression</a> <br>
                                 <a href="jls-9.html#jls-ElementValueArrayInitializer" title="ElementValueArrayInitializer">ElementValueArrayInitializer</a> <br>
                                 <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">ElementValueArrayInitializer:</div>
                            
                        <div class="rhs">
                                 <code class="literal">{</code> [<a href="jls-9.html#jls-ElementValueList" title="ElementValueList">ElementValueList</a>] [<code class="literal">,</code>] <code class="literal">}</code>
                              
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">ElementValueList:</div>
                            
                        <div class="rhs">
                                 <a href="jls-9.html#jls-ElementValue" title="ElementValue">ElementValue</a> {<code class="literal">,</code> <a href="jls-9.html#jls-ElementValue" title="ElementValue">ElementValue</a>}
                               
                        </div>
                          
                     </div>
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-9.6.2-120"></a>
                  It is a compile-time error if the type of the element is not commensurate
                  (<a class="xref" href="jls-9.html#jls-9.7" title="9.7.&nbsp;Annotations">&sect;9.7</a>) with the default value specified.
               </p>
               <p class="norm-dynamic"><a name="jls-9.6.2-200"></a>Default
                  values are not compiled into annotations, but rather applied
                  dynamically at the time annotations are read. Thus, changing a default
                  value affects annotations even in classes that were compiled before
                  the change was made (presuming these annotations lack an explicit
                  value for the defaulted element).
               </p>
               <div class="example"><a name="d5e18300"></a><p class="title"><b>Example&nbsp;9.6.2-1.&nbsp;Annotation Interface Declaration With Default Values</b></p>
                  <div class="example-contents">
                     <p class="note">Here is a refinement of the
                        <code class="literal">RequestForEnhancement</code> annotation interface from
                        <a class="xref" href="jls-9.html#jls-9.6.1" title="9.6.1.&nbsp;Annotation Interface Elements">&sect;9.6.1</a>:
                     </p><pre class="programlisting">
@interface RequestForEnhancement {
    int    id();       // No default - must be specified in 
                       // each annotation
    String synopsis(); // No default - must be specified in 
                       // each annotation
    String engineer()  default "[unassigned]";
    String date()      default "[unimplemented]";
}

</pre></div>
               </div><br class="example-break"></div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.6.3"></a>9.6.3.&nbsp;Repeatable Annotation Interfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.6.3-100"></a>
                  An annotation interface <span class="type">A</span> is <span class="emphasis"><em>repeatable</em></span> if its
                  declaration is (meta-)annotated with an <code class="literal">@Repeatable</code> annotation
                  (<a class="xref" href="jls-9.html#jls-9.6.4.8" title="9.6.4.8.&nbsp;@Repeatable">&sect;9.6.4.8</a>) whose <code class="literal">value</code> element indicates
                  a <span class="emphasis"><em>containing annotation interface of <span class="type">A</span></em></span>.
               </p>
               <p class="norm-static"><a name="jls-9.6.3-110"></a>
                  An annotation interface <span class="type">AC</span> is a <span class="emphasis"><em>containing annotation
                        interface of <span class="type">A</span></em></span> if all of the following are true:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" type="1">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.6.3-110-A"></a>
                                 <span class="type">AC</span> declares a <code class="literal">value()</code> method whose return
                                 type is <span class="type">A</span><code class="literal">[]</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.6.3-110-B"></a>
                                 Any methods declared by <span class="type">AC</span> other than <code class="literal">value()</code> 
                                 have a default value.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.6.3-110-C"></a>
                                 <span class="type">AC</span> is retained for at least as long as <span class="type">A</span>, where retention is
                                 expressed explicitly or implicitly with the <code class="literal">@Retention</code>
                                 annotation (<a class="xref" href="jls-9.html#jls-9.6.4.2" title="9.6.4.2.&nbsp;@Retention">&sect;9.6.4.2</a>). Specifically:
                        </p>
                        <div class="norm">
                           <ul class="norm" style="list-style-type: disc; ">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-9.6.3-110-C-A"></a>
                                    	  If the retention of <span class="type">AC</span> is <code class="literal">java.lang.annotation.RetentionPolicy.SOURCE</code>, then
                                              the retention of <span class="type">A</span> is <code class="literal">java.lang.annotation.RetentionPolicy.SOURCE</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-9.6.3-110-C-B"></a>
                                    	  If the retention of <span class="type">AC</span> is <code class="literal">java.lang.annotation.RetentionPolicy.CLASS</code>, then the
                                              retention of <span class="type">A</span> is either <code class="literal">java.lang.annotation.RetentionPolicy.CLASS</code> or
                                              <code class="literal">java.lang.annotation.RetentionPolicy.SOURCE</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-9.6.3-110-C-C"></a>
                                    	  If the retention of <span class="type">AC</span> is <code class="literal">java.lang.annotation.RetentionPolicy.RUNTIME</code>, then
                                              the retention of <span class="type">A</span> is <code class="literal">java.lang.annotation.RetentionPolicy.SOURCE</code>,
                                              <code class="literal">java.lang.annotation.RetentionPolicy.CLASS</code>, or <code class="literal">java.lang.annotation.RetentionPolicy.RUNTIME</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.6.3-110-D"></a>
                                 <span class="type">A</span> is applicable to at least the same kinds of program element
                                 as <span class="type">AC</span> (<a class="xref" href="jls-9.html#jls-9.6.4.1" title="9.6.4.1.&nbsp;@Target">&sect;9.6.4.1</a>). Specifically, if the
                                 kinds of program element where <span class="type">A</span> is applicable are denoted by
                                 the set <code class="varname">m<sub>1</sub></code>, and the kinds of program element where <span class="type">AC</span> is
                                 applicable are denoted by the set <code class="varname">m<sub>2</sub></code>, then each kind in <code class="varname">m<sub>2</sub></code>
                                 must occur in <code class="varname">m<sub>1</sub></code>, except that:
                        </p>
                        <div class="norm">
                           <ul class="norm" style="list-style-type: disc; ">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-9.6.3-110-D-A"></a>
                                    	  If the kind in <code class="varname">m<sub>2</sub></code> is <code class="literal">java.lang.annotation.ElementType.ANNOTATION_TYPE</code>, then at
                                              least one of <code class="literal">java.lang.annotation.ElementType.ANNOTATION_TYPE</code> or
                                              <code class="literal">java.lang.annotation.ElementType.TYPE</code> or <code class="literal">java.lang.annotation.ElementType.TYPE_USE</code> must occur in
                                              <code class="varname">m<sub>1</sub></code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-9.6.3-110-D-B"></a>
                                    	  If the kind in <code class="varname">m<sub>2</sub></code> is <code class="literal">java.lang.annotation.ElementType.TYPE</code>, then at least one
                                              of <code class="literal">java.lang.annotation.ElementType.TYPE</code> or <code class="literal">java.lang.annotation.ElementType.TYPE_USE</code> must occur in
                                              <code class="varname">m<sub>1</sub></code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-9.6.3-110-D-C"></a>
                                    	  If the kind in <code class="varname">m<sub>2</sub></code> is <code class="literal">java.lang.annotation.ElementType.TYPE_PARAMETER</code>, then at
                                              least one of <code class="literal">java.lang.annotation.ElementType.TYPE_PARAMETER</code> or
                                              <code class="literal">java.lang.annotation.ElementType.TYPE_USE</code> must occur in <code class="varname">m<sub>1</sub></code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p class="note">This clause implements the policy that an
                                 annotation interface may be <span class="emphasis"><em>repeatable</em></span> on
                                 only some of the kinds of program element where it is
                                 <span class="emphasis"><em>applicable</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.6.3-110-E"></a>
                                 If the declaration of <span class="type">A</span> has a (meta-)annotation that
                                 corresponds to <code class="literal">java.lang.annotation.Documented</code>, then the declaration of <span class="type">AC</span> must
                                 have a (meta-)annotation that corresponds to <code class="literal">java.lang.annotation.Documented</code>.
                        </p>
                        <p class="note">Note that it is permissible for <span class="type">AC</span> to be
                                 <code class="literal">@Documented</code> while <span class="type">A</span> is not <code class="literal">@Documented</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.6.3-110-F"></a>
                                 If the declaration of <span class="type">A</span> has a (meta-)annotation that
                                 corresponds to <code class="literal">java.lang.annotation.Inherited</code>, then the declaration of <span class="type">AC</span> must
                                 have a (meta)-annotation that corresponds to <code class="literal">java.lang.annotation.Inherited</code>.
                        </p>
                        <p class="note">Note that it is permissible for <span class="type">AC</span> to be
                                 <code class="literal">@Inherited</code> while <span class="type">A</span> is not <code class="literal">@Inherited</code>.
                        </p>
                     </li>
                  </ol>
               </div>
               <p class="norm-error"><a name="jls-9.6.3-120"></a>
                  It is a compile-time error if an annotation interface <span class="type">A</span> is
                  (meta-)annotated with an <code class="literal">@Repeatable</code> annotation whose <code class="literal">value</code>
                  element indicates a type which is not a containing annotation interface
                  of <span class="type">A</span>.
               </p>
               <div class="example"><a name="d5e18433"></a><p class="title"><b>Example&nbsp;9.6.3-1.&nbsp;Ill-formed Containing Annotation Interface</b></p>
                  <div class="example-contents">
                     <p class="note">Consider the following declarations:</p><pre class="programlisting">
import java.lang.annotation.Repeatable;

@Repeatable(FooContainer.class)
@interface Foo {}

@interface FooContainer { Object[] value(); }
</pre><p class="note">Compiling the <code class="literal">Foo</code> declaration
                        produces a compile-time error because <code class="literal">Foo</code> uses
                        <code class="literal">@Repeatable</code> to attempt to specify <code class="literal">FooContainer</code>
                        as its containing annotation interface, but <code class="literal">FooContainer</code>
                        is not in fact a containing annotation interface of <code class="literal">Foo</code>.
                        (The return type of <code class="literal">FooContainer.value()</code> is
                        not <code class="literal">Foo</code><code class="literal">[]</code>.)
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm-static"><a name="jls-9.6.3-200"></a>
                  The <code class="literal">@Repeatable</code> annotation cannot be repeated, so only one containing
                  annotation interface can be specified by a repeatable annotation
                  interface.
               </p>
               <p class="note">Allowing more than one containing annotation interface
                  to be specified would cause an undesirable choice at compile time, when
                  multiple annotations of the repeatable annotation interface are logically
                  replaced with a container annotation (<a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Interface">&sect;9.7.5</a>).
               </p>
               <p class="norm-static"><a name="jls-9.6.3-210"></a>
                  An annotation interface can be the containing annotation interface
                  of at most one annotation interface.
               </p>
               <p class="note">This is implied by the requirement that if the
                  declaration of an annotation interface <span class="type">A</span> specifies a containing
                  annotation interface of <span class="type">AC</span>, then the <code class="literal">value()</code> 
                  method of <span class="type">AC</span> has a return type involving <span class="type">A</span>, specifically
                  <span class="type">A</span><code class="literal">[]</code>.
               </p>
               <p class="norm-static"><a name="jls-9.6.3-220"></a>
                  An annotation interface cannot specify itself as its containing 
                  annotation interface.
               </p>
               <p class="note">This is implied by the requirement on
                  the <code class="literal">value()</code> method of the containing annotation
                  interface. Specifically, if an annotation interface <span class="type">A</span> specified itself 
                  (via <code class="literal">@Repeatable</code>) as its containing annotation interface, then the 
                  return type of <span class="type">A</span>'s <code class="literal">value()</code> method would have to be
                  <span class="type">A</span><code class="literal">[]</code>; but this would cause a compile-time error since an
                  annotation interface cannot refer to itself in its elements
                  (<a class="xref" href="jls-9.html#jls-9.6.1" title="9.6.1.&nbsp;Annotation Interface Elements">&sect;9.6.1</a>). More generally, two annotation interfaces
                  cannot specify each other as their containing annotation interface,
                  because cyclic annotation interface declarations are illegal.
               </p>
               <p class="norm-static"><a name="jls-9.6.3-230"></a>
                  An annotation interface <span class="type">AC</span> may be the containing annotation interface
                  of some annotation interface <span class="type">A</span> while also having its own containing 
                  annotation interface <span class="type">SC</span>. That is, a containing annotation interface 
                  may itself be a repeatable annotation interface.
               </p>
               <div class="example"><a name="d5e18474"></a><p class="title"><b>Example&nbsp;9.6.3-2.&nbsp;Restricting Where Annotations May Repeat</b></p>
                  <div class="example-contents">
                     <p class="note">An annotation whose interface declaration indicates a
                        target of <code class="literal">java.lang.annotation.ElementType.TYPE</code> can appear in at least as many locations
                        as an annotation whose interface declaration indicates a target of
                        <code class="literal">java.lang.annotation.ElementType.ANNOTATION_TYPE</code>. For example, given the following
                        declarations of repeatable and containing annotation interfaces:
                     </p><pre class="programlisting">
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;

@Target(ElementType.TYPE)
@Repeatable(FooContainer.class)
@interface Foo {}

@Target(ElementType.ANNOTATION_TYPE)
@interface FooContainer {
    Foo[] value();
}
</pre><p class="note"><code class="literal">@Foo</code> can appear on any class or
                        interface declaration while <code class="literal">@FooContainer</code> can appear on 
                        only annotation interface declarations. Therefore, the following annotation 
                        interface declaration is legal:
                     </p><pre class="programlisting">
@Foo @Foo
@interface Anno {}
</pre><p class="note">while the following interface declaration is
                        illegal:
                     </p><pre class="programlisting">
@Foo @Foo
interface Intf {}
</pre><p class="note">More broadly, if <code class="literal">Foo</code> is a
                        repeatable annotation interface and <code class="literal">FooContainer</code> is its
                        containing annotation interface, then:
                     </p>
                     <div class="note">
                        <ul class="note" style="list-style-type: disc; ">
                           <li class="listitem">
                              <p class="note">If <code class="literal">Foo</code> has no <code class="literal">@Target</code>
                                       meta-annotation and <code class="literal">FooContainer</code> has no
                                       <code class="literal">@Target</code> meta-annotation, then <code class="literal">@Foo</code> may be
                                       repeated on any program element which supports annotations.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">If <code class="literal">Foo</code> has no <code class="literal">@Target</code>
                                       meta-annotation but <code class="literal">FooContainer</code> has an
                                       <code class="literal">@Target</code> meta-annotation, then <code class="literal">@Foo</code> may
                                       only be repeated on program elements where 
                                       <code class="literal">@FooContainer</code> may appear.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">If <code class="literal">Foo</code> has an <code class="literal">@Target</code>
                                       meta-annotation, then in the judgment of the designers of the
                                       Java programming language, <code class="literal">FooContainer</code> must be declared
                                       with knowledge of the <code class="literal">Foo</code>'s applicability. 
                                       Specifically, the kinds of program element where 
                                       <code class="literal">FooContainer</code> may appear must logically
                                       be the same as, or a subset of, <code class="literal">Foo</code>'s
                                       kinds.
                              </p>
                              <p class="note">For example, if <code class="literal">Foo</code> is
                                       applicable to field and method declarations,
                                       then <code class="literal">FooContainer</code> may legitimately serve
                                       as <code class="literal">Foo</code>'s containing annotation interface
                                       if <code class="literal">FooContainer</code> is applicable to just field
                                       declarations (preventing <code class="literal">@Foo</code> from being
                                       repeated on method declarations). But if 
                                       <code class="literal">FooContainer</code> is applicable only to formal
                                       parameter declarations, then <code class="literal">FooContainer</code> was
                                       a poor choice of containing annotation interface by 
                                       <code class="literal">Foo</code> because <code class="literal">@FooContainer</code> 
                                       cannot be implicitly declared on some program elements where 
                                       <code class="literal">@Foo</code> is repeated.
                              </p>
                              <p class="note">Similarly, if <code class="literal">Foo</code> is
                                       applicable to field and method declarations,
                                       then <code class="literal">FooContainer</code> cannot legitimately serve
                                       as <code class="literal">Foo</code>'s containing annotation interface
                                       if <code class="literal">FooContainer</code> is applicable to field and
                                       parameter declarations. While it would be possible to take the
                                       intersection of the program elements and make 
                                       <code class="literal">Foo</code> repeatable on field declarations only, 
                                       the presence of additional program elements for 
                                       <code class="literal">FooContainer</code> indicates that 
                                       <code class="literal">FooContainer</code> was not designed as a
                                       containing annotation interface for <code class="literal">Foo</code>. 
                                       It would therefore be dangerous for <code class="literal">Foo</code> 
                                       to rely on it.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e18534"></a><p class="title"><b>Example&nbsp;9.6.3-3.&nbsp;A Repeatable Containing Annotation Interface</b></p>
                  <div class="example-contents">
                     <p class="note">The following declarations are legal:</p><pre class="programlisting">
import java.lang.annotation.Repeatable;

// Foo: Repeatable annotation interface
@Repeatable(FooContainer.class)
@interface Foo { int value(); }

// FooContainer: Containing annotation interface of Foo
// Also a repeatable annotation interface itself
@Repeatable(FooContainerContainer.class)
@interface FooContainer { Foo[] value(); }

// FooContainerContainer: Containing annotation interface
// of FooContainer
@interface FooContainerContainer { FooContainer[] value(); }

</pre><p class="note">Thus, an annotation whose interface is a containing
                        annotation interface may itself be repeated:
                     </p><pre class="programlisting">
@FooContainer({@Foo(1)}) @FooContainer({@Foo(2)})
class Test {}
</pre><p class="note">An annotation interface which is both repeatable and
                        containing is subject to the rules on mixing annotations of repeatable
                        annotation interface with annotations of containing annotation interface
                        (<a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Interface">&sect;9.7.5</a>). For example, it is not possible to
                        write multiple <code class="literal">@Foo</code> annotations alongside
                        multiple <code class="literal">@FooContainer</code> annotations, nor is it
                        possible to write multiple <code class="literal">@FooContainer</code>
                        annotations alongside multiple <code class="literal">@FooContainerContainer</code>
                        annotations. However, if the annotation interface 
                        <code class="literal">FooContainerContainer</code> was itself repeatable, then it 
                        would be possible to write multiple <code class="literal">@Foo</code> annotations 
                        alongside multiple <code class="literal">@FooContainerContainer</code> 
                        annotations.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.6.4"></a>9.6.4.&nbsp;Predefined Annotation Interfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.6.4-100"></a>
                  Several annotation interfaces are predefined in the Java SE Platform API.
                  Some of the predefined annotation interfaces have special semantics
                  in the Java programming language and require special behavior on the part of a Java
                  compiler, as specified in this section. This section does not provide
                  a complete specification for the predefined annotation interfaces,
                  for which the reader is referred to the Java SE Platform API documentation
                  (<a class="xref" href="jls-1.html#jls-1.4" title="1.4.&nbsp;Relationship to Predefined Classes and Interfaces">&sect;1.4</a>).
               </p>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.6.4.1"></a>9.6.4.1.&nbsp;<code class="literal">@Target</code></h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-9.6.4.1-100"></a>
                     An annotation of type <code class="literal">java.lang.annotation.Target</code> is used on the declaration of an
                     annotation interface <span class="type">A</span> to specify the contexts in which <span class="type">A</span>
                     is <span class="emphasis"><em>applicable</em></span>. <code class="literal">java.lang.annotation.Target</code> has a single element,
                     <code class="literal">value</code>, of type <code class="literal">java.lang.annotation.ElementType</code><code class="literal">[]</code>, to specify contexts.
                  </p>
                  <p class="norm-static"><a name="jls-9.6.4.1-200"></a>
                     Annotation interfaces may be applicable in <span class="emphasis"><em>declaration
                           contexts</em></span>, where annotations apply to declarations, or
                     in <span class="emphasis"><em>type contexts</em></span>, where annotations apply to
                     types used in declarations and expressions.
                  </p>
                  <p class="norm-static"><a name="jls-9.6.4.1-210"></a>
                     
                     There are  ten declaration contexts, each corresponding to
                     an enum constant of <code class="literal">java.lang.annotation.ElementType</code>:
                  </p>
                  <div class="orderedlist">
                     <ol class="orderedlist" type="1">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.1-210-AA"></a>
                                    Module declarations (<a class="xref" href="jls-7.html#jls-7.7" title="7.7.&nbsp;Module Declarations">&sect;7.7</a>)
                           </p>
                           <p class="norm-static"><a name="jls-9.6.4.1-210-AA.1"></a>
                                    Corresponds to <code class="literal">java.lang.annotation.ElementType.MODULE</code></p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.1-210-A"></a>
                                    Package declarations (<a class="xref" href="jls-7.html#jls-7.4.1" title="7.4.1.&nbsp;Named Packages">&sect;7.4.1</a>)
                           </p>
                           <p class="norm-static"><a name="jls-9.6.4.1-210-A.1"></a>
                                    Corresponds to <code class="literal">java.lang.annotation.ElementType.PACKAGE</code></p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.1-210-B"></a>
                                    Class declarations (including enum declarations and record
                                    declarations) and interface declarations (including annotation
                                    interface declarations) (<a class="xref" href="jls-8.html#jls-8.1.1" title="8.1.1.&nbsp;Class Modifiers">&sect;8.1.1</a>, <a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Class and Interface Declarations">&sect;8.5</a>, <a class="xref" href="jls-8.html#jls-8.9" title="8.9.&nbsp;Enum Classes">&sect;8.9</a>, <a class="xref" href="jls-8.html#jls-8.10" title="8.10.&nbsp;Record Classes">&sect;8.10</a>, <a class="xref" href="jls-9.html#jls-9.1.1" title="9.1.1.&nbsp;Interface Modifiers">&sect;9.1.1</a>, <a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Class and Interface Declarations">&sect;9.5</a>, <a class="xref" href="jls-9.html#jls-9.6" title="9.6.&nbsp;Annotation Interfaces">&sect;9.6</a>)
                           </p>
                           <p class="norm-static"><a name="jls-9.6.4.1-210-B.1"></a>
                                    Corresponds to <code class="literal">java.lang.annotation.ElementType.TYPE</code></p>
                           <p class="norm-static"><a name="jls-9.6.4.1-210-B.2"></a>
                                    Additionally, annotation interface declarations correspond to
                                    <code class="literal">java.lang.annotation.ElementType.ANNOTATION_TYPE</code></p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.1-210-C"></a>
                                    Method declarations (including elements of annotation interfaces)
                                    (<a class="xref" href="jls-8.html#jls-8.4.3" title="8.4.3.&nbsp;Method Modifiers">&sect;8.4.3</a>, <a class="xref" href="jls-9.html#jls-9.4" title="9.4.&nbsp;Method Declarations">&sect;9.4</a>,
                                    <a class="xref" href="jls-9.html#jls-9.6.1" title="9.6.1.&nbsp;Annotation Interface Elements">&sect;9.6.1</a>)
                           </p>
                           <p class="norm-static"><a name="jls-9.6.4.1-210-C.1"></a>
                                    Corresponds to <code class="literal">java.lang.annotation.ElementType.METHOD</code></p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.1-210-D"></a>
                                    Constructor declarations (<a class="xref" href="jls-8.html#jls-8.8.3" title="8.8.3.&nbsp;Constructor Modifiers">&sect;8.8.3</a>)
                           </p>
                           <p class="norm-static"><a name="jls-9.6.4.1-210-D.1"></a>
                                    Corresponds to <code class="literal">java.lang.annotation.ElementType.CONSTRUCTOR</code></p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.1-210-E"></a>
                                    Type parameter declarations of generic classes, interfaces,
                                    methods, and constructors (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>,
                                    <a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>, <a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>,
                                    <a class="xref" href="jls-8.html#jls-8.8.4" title="8.8.4.&nbsp;Generic Constructors">&sect;8.8.4</a>)
                           </p>
                           <p class="norm-static"><a name="jls-9.6.4.1-210-E.1"></a>
                                    Corresponds to <code class="literal">java.lang.annotation.ElementType.TYPE_PARAMETER</code></p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.1-210-F"></a>
                                    Field declarations (including enum constants)
                                    (<a class="xref" href="jls-8.html#jls-8.3.1" title="8.3.1.&nbsp;Field Modifiers">&sect;8.3.1</a>, <a class="xref" href="jls-9.html#jls-9.3" title="9.3.&nbsp;Field (Constant) Declarations">&sect;9.3</a>,
                                    <a class="xref" href="jls-8.html#jls-8.9.1" title="8.9.1.&nbsp;Enum Constants">&sect;8.9.1</a>)
                           </p>
                           <p class="norm-static"><a name="jls-9.6.4.1-210-F.1"></a>
                                    Corresponds to <code class="literal">java.lang.annotation.ElementType.FIELD</code></p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.1-210-G"></a>
                                    Formal and exception parameter declarations
                                    (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>, <a class="xref" href="jls-9.html#jls-9.4" title="9.4.&nbsp;Method Declarations">&sect;9.4</a>,
                                    <a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>)
                           </p>
                           <p class="norm-static"><a name="jls-9.6.4.1-210-G.1"></a>
                                    Corresponds to <code class="literal">java.lang.annotation.ElementType.PARAMETER</code></p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.1-210-H"></a>
                                    Local variable declarations in statements (<a class="xref" href="jls-14.html#jls-14.4.2" title="14.4.2.&nbsp;Local Variable Declaration Statements">&sect;14.4.2</a>, <a class="xref" href="jls-14.html#jls-14.14.1" title="14.14.1.&nbsp;The basic for Statement">&sect;14.14.1</a>, <a class="xref" href="jls-14.html#jls-14.14.2" title="14.14.2.&nbsp;The enhanced for statement">&sect;14.14.2</a>, <a class="xref" href="jls-14.html#jls-14.20.3" title="14.20.3.&nbsp;try-with-resources">&sect;14.20.3</a>) and
                                    in patterns (<a class="xref" href="jls-14.html#jls-14.30.1" title="14.30.1.&nbsp;Kinds of Patterns">&sect;14.30.1</a>)
                           </p>
                           <p class="norm-static"><a name="jls-9.6.4.1-210-H.1"></a>
                                    Corresponds to <code class="literal">java.lang.annotation.ElementType.LOCAL_VARIABLE</code></p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.1-210-I"></a>
                                    Record component declarations (<a class="xref" href="jls-8.html#jls-8.10.1" title="8.10.1.&nbsp;Record Components">&sect;8.10.1</a>)
                           </p>
                           <p class="norm-static"><a name="jls-9.6.4.1-210-I.1"></a>
                                    Corresponds to <code class="literal">java.lang.annotation.ElementType.RECORD_COMPONENT</code></p>
                        </li>
                     </ol>
                  </div>
                  <p class="norm-static"><a name="jls-9.6.4.1-220"></a>
                     There are  17 type contexts (<a class="xref" href="jls-4.html#jls-4.11" title="4.11.&nbsp;Where Types Are Used">&sect;4.11</a>), all
                     represented by the enum constant <code class="literal">TYPE_USE</code> of
                     <code class="literal">java.lang.annotation.ElementType</code>.
                  </p>
                  <p class="norm-error"><a name="jls-9.6.4.1-300"></a>
                     It is a compile-time error if the same enum constant appears more than
                     once in the <code class="literal">value</code> element of an annotation of type <code class="literal">java.lang.annotation.Target</code>.
                  </p>
                  <p class="norm-static"><a name="jls-9.6.4.1-400"></a>
                     If an annotation of type <code class="literal">java.lang.annotation.Target</code> is not present on the declaration of
                     an annotation interface <span class="type">A</span>, then <span class="type">A</span> is applicable in all
                     declaration contexts and in no type contexts.
                  </p>
               </div>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.6.4.2"></a>9.6.4.2.&nbsp;<code class="literal">@Retention</code></h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-9.6.4.2-100"></a>
                     Annotations may be present only in source code, or they may be present
                     in the binary form of a class or interface. An annotation that is
                     present in the binary form may or may not be available at run time via
                     the reflection libraries of the Java SE Platform. The annotation interface
                     <code class="literal">java.lang.annotation.Retention</code> is used to choose among these possibilities.
                  </p>
                  <p class="norm-static"><a name="jls-9.6.4.2-110"></a>
                     If an annotation <code class="varname">a</code> corresponds to an annotation interface <span class="type">A</span>, 
                     and <span class="type">A</span> has a (meta-)annotation <code class="varname">m</code> that corresponds to <code class="literal">java.lang.annotation.Retention</code>, 
                     then:
                  </p>
                  <div class="norm">
                     <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.2-110-A"></a>
                                    If <code class="varname">m</code> has an element whose value is <code class="literal">java.lang.annotation.RetentionPolicy.SOURCE</code>,
                                    then a Java compiler must ensure that <code class="varname">a</code> is not present in the
                                    binary representation of the class or interface in which <code class="varname">a</code>
                                    appears.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.2-110-B"></a>
                                    If <code class="varname">m</code> has an element whose value is <code class="literal">java.lang.annotation.RetentionPolicy.CLASS</code> or
                                    <code class="literal">java.lang.annotation.RetentionPolicy.RUNTIME</code>, then a Java compiler must ensure that
                                    <code class="varname">a</code> is represented in the binary representation of the class or
                                    interface in which <code class="varname">a</code> appears, unless <code class="varname">a</code> annotates a local
                                    variable declaration or <code class="varname">a</code> annotates a formal parameter
                                    declaration of a lambda expression.
                           </p>
                           <p class="norm-static"><a name="jls-9.6.4.2-110-B.1"></a>
                                    An annotation on the declaration of a local variable, or on the
                                    declaration of a formal parameter of a lambda expression, is
                                    never retained in the binary representation. In contrast, an
                                    annotation on the type of a local variable, or on the type of a
                                    formal parameter of a lambda expression, is retained in the
                                    binary representation if the annotation interface specifies a
                                    suitable retention policy.
                           </p>
                           <p class="note">
                                    Note that it is not illegal for an annotation interface to be
                                    meta-annotated with
                                    <code class="literal">@Target</code><code class="literal">(</code><code class="literal">java.lang.annotation.ElementType.LOCAL_VARIABLE</code><code class="literal">)</code> 
                                    <span class="emphasis"><em>and</em></span>
                                    <code class="literal">@Retention</code><code class="literal">(</code><code class="literal">java.lang.annotation.RetentionPolicy.CLASS</code><code class="literal">)</code> or
                                    <code class="literal">@Retention</code><code class="literal">(</code><code class="literal">java.lang.annotation.RetentionPolicy.RUNTIME</code><code class="literal">)</code>.
                           </p>
                           <p class="norm-static"><a name="jls-9.6.4.2-110-B.2"></a>
                                    If <code class="varname">m</code> has an element whose value is <code class="literal">java.lang.annotation.RetentionPolicy.RUNTIME</code>,
                                    the reflection libraries of the Java SE Platform must make <code class="varname">a</code>
                                    available at run time.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-9.6.4.2-120"></a>
                     If <span class="type">A</span> does not have a (meta-)annotation that corresponds to 
                     <code class="literal">java.lang.annotation.Retention</code>, then a Java compiler must treat <span class="type">A</span> as if it has a
                     (meta-)annotation that corresponds to <code class="literal">java.lang.annotation.Retention</code> with an element
                     whose value is <code class="literal">java.lang.annotation.RetentionPolicy.CLASS</code>.
                  </p>
               </div>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.6.4.3"></a>9.6.4.3.&nbsp;<code class="literal">@Inherited</code></h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-9.6.4.3-100"></a>
                     The annotation interface <code class="literal">java.lang.annotation.Inherited</code> is used to indicate that 
                     annotations on a class <span class="type">C</span> corresponding to a given annotation
                     interface are inherited by subclasses of <span class="type">C</span>.
                  </p>
               </div>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.6.4.4"></a>9.6.4.4.&nbsp;<code class="literal">@Override</code></h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-9.6.4.4-100"></a>
                     Programmers occasionally overload a method declaration when they mean
                     to override it, leading to subtle problems. The annotation interface
                     <code class="literal">Override</code> supports early detection of such problems.
                  </p>
                  <div class="informalexample">
                     <p class="note">The classic example concerns the <code class="literal">equals</code> 
                        method. Programmers write the following in class <code class="literal">Foo</code>:
                     </p><pre class="screen">
public boolean equals(Foo that) { ... }
</pre><p class="note">when they mean to write:</p><pre class="screen">
public boolean equals(Object that) { ... }
</pre><p class="note">This is perfectly legal, but class 
                        <code class="literal">Foo</code> inherits the <code class="literal">equals</code>
                        implementation from <code class="literal">Object</code>, which can cause some subtle bugs.
                     </p>
                  </div>
                  <p class="norm-error"><a name="jls-9.6.4.4-200"></a>
                     
                     If a method declaration in class or interface <span class="type">Q</span> is annotated 
                     with <code class="literal">@Override</code>, then one of the following three conditions must be
                     true, or a compile-time error occurs:
                  </p>
                  <div class="norm">
                     <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-9.6.4.4-200-A"></a>
                                    the method overrides from <span class="type">Q</span> a method declared in a supertype
                                    of <span class="type">Q</span> (<a class="xref" href="jls-8.html#jls-8.4.8.1" title="8.4.8.1.&nbsp;Overriding (by Instance Methods)">&sect;8.4.8.1</a>, <a class="xref" href="jls-9.html#jls-9.4.1.1" title="9.4.1.1.&nbsp;Overriding (by Instance Methods)">&sect;9.4.1.1</a>)
                                  
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-9.6.4.4-200-B"></a>
                                    the method is override-equivalent to a <code class="literal">public</code> method of <code class="literal">Object</code>
                                    (<a class="xref" href="jls-4.html#jls-4.3.2" title="4.3.2.&nbsp;The Class Object">&sect;4.3.2</a>, <a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-9.6.4.4-200-C"></a>
                                    <span class="type">Q</span> is a record class (<a class="xref" href="jls-8.html#jls-8.10" title="8.10.&nbsp;Record Classes">&sect;8.10</a>), and the method
                                    is an accessor method for a record component of <span class="type">Q</span>
                                    (<a class="xref" href="jls-8.html#jls-8.10.3" title="8.10.3.&nbsp;Record Members">&sect;8.10.3</a>)
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="note">This behavior differs from Java SE 5.0, where
                     <code class="literal">@Override</code> only caused a compile-time error if applied to a method
                     that implemented a method from a superinterface that was not also
                     present in a superclass.
                  </p>
                  <div class="informalexample">
                     <p class="note">The clause about overriding a <code class="literal">public</code> method of
                        <code class="literal">Object</code> is motivated by use of <code class="literal">@Override</code> in an interface. Consider
                        the following declarations:
                     </p><pre class="screen">
class Foo     { @Override public int hashCode() {..} }
interface Bar { @Override int hashCode(); }
</pre><p class="note">The use of <code class="literal">@Override</code> in the class declaration is
                        legal by the first clause, because <code class="literal">Foo.hashCode</code>
                        overrides from <code class="literal">Foo</code> the method
                        <code class="literal">Object.hashCode</code>.
                     </p>
                     <p class="note">
                        For the interface declaration, consider that  an interface has <code class="literal">public</code>
                        <code class="literal">abstract</code> members which correspond to the <code class="literal">public</code> members of
                        <code class="literal">Object</code> (<a class="xref" href="jls-9.html#jls-9.2" title="9.2.&nbsp;Interface Members">&sect;9.2</a>). If an interface chooses to
                        declare them explicitly (that is, to declare members that are
                        override-equivalent to <code class="literal">public</code> methods of <code class="literal">Object</code>), then the
                        interface is deemed to override them, and use of <code class="literal">@Override</code> is
                        allowed.
                     </p>
                     <p class="note">However, consider an interface that attempts to use
                        <code class="literal">@Override</code> on a <code class="literal">clone</code> method:
                        (<code class="literal">finalize</code> could also be used in this example)
                     </p><pre class="screen">
interface Quux { @Override Object clone(); }
</pre><p class="note">Because <code class="literal">Object.clone</code> is not
                        <code class="literal">public</code>, there is no member called <code class="literal">clone</code>
                        implicitly declared in <code class="literal">Quux</code>. Therefore, the
                        explicit declaration of <code class="literal">clone</code> in 
                        <code class="literal">Quux</code> is not deemed to "implement" any other
                        method, and it is erroneous to use <code class="literal">@Override</code>. (The fact
                        that <code class="literal">Quux.clone</code> is <code class="literal">public</code> is not relevant.)
                     </p>
                     <p class="note">In contrast, a class declaration that declares 
                        <code class="literal">clone</code> is simply overriding <code class="literal">Object.clone</code>, 
                        so is able to use <code class="literal">@Override</code>:
                     </p><pre class="screen">
class Beep { @Override protected Object clone() {..} }
</pre></div>
                  <div class="informalexample">
                     <p class="note">The clause about a record class is due to the
                        special meaning of <code class="literal">@Override</code> in a record declaration. Namely, it
                        can be used to specify that a method declaration is an accessor method
                        for a record component. Consider the following record declaration:
                     </p><pre class="programlisting">
record Roo(int x) {
    @Override
    public int x() {
        return Math.abs(x);
    }
}

</pre><p class="note">The use of <code class="literal">@Override</code> on the accessor method
                        <code class="literal">int x()</code> ensures that if the record component
                        <code class="literal">x</code> is modified or removed, then the corresponding
                        accessor method must be modified or removed too.
                     </p>
                  </div>
               </div>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.6.4.5"></a>9.6.4.5.&nbsp;<code class="literal">@SuppressWarnings</code></h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-9.6.4.5-100"></a>
                     Java compilers are increasingly capable of issuing helpful "lint-like"
                     warnings. To encourage the use of such warnings, there should be some
                     way to disable a warning in a part of the program when the programmer
                     knows that the warning is inappropriate.
                  </p>
                  <p class="norm-static"><a name="jls-9.6.4.5-110"></a>
                     The annotation interface <code class="literal">SuppressWarnings</code> supports programmer control
                     over warnings otherwise issued by a Java compiler. It defines a single
                     element that is an array of <code class="literal">String</code>.
                  </p>
                  <p class="norm-static"><a name="jls-9.6.4.5-200"></a>
                     If a declaration is annotated with <code class="literal">@SuppressWarnings</code><code class="literal">(value
                        = {<span class="type">S<sub>1</sub></span>, ..., <span class="type">S<sub>k</sub></span>})</code>, then a Java compiler must suppress
                     (that is, not report) any warning specified by one of <span class="type">S<sub>1</sub></span> ... <span class="type">S<sub>k</sub></span> if
                     that warning would have been generated as a result of the annotated
                     declaration or any of its parts.
                  </p>
                  <p class="norm-static"><a name="jls-9.6.4.5-210"></a>
                     
                     The Java programming language defines four kinds of warnings that can be specified by
                     <code class="literal">@SuppressWarnings</code>:
                  </p>
                  <div class="norm">
                     <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.5-210-A"></a>
                                    Unchecked warnings (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>,
                                    <a class="xref" href="jls-5.html#jls-5.1.6" title="5.1.6.&nbsp;Narrowing Reference Conversion">&sect;5.1.6</a>, <a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>,
                                    <a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>, <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>,
                                    <a class="xref" href="jls-15.html#jls-15.12.4.2" title="15.12.4.2.&nbsp;Evaluate Arguments">&sect;15.12.4.2</a>, <a class="xref" href="jls-15.html#jls-15.13.2" title="15.13.2.&nbsp;Type of a Method Reference">&sect;15.13.2</a>,
                                    <a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>) are specified by the string
                                    "<code class="literal">unchecked</code>".
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.5-210-B"></a>
                                    Deprecation warnings (<a class="xref" href="jls-9.html#jls-9.6.4.6" title="9.6.4.6.&nbsp;@Deprecated">&sect;9.6.4.6</a>) are
                                    specified by the string "<code class="literal">deprecation</code>".
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.5-210-C"></a>
                                    Removal warnings (<a class="xref" href="jls-9.html#jls-9.6.4.6" title="9.6.4.6.&nbsp;@Deprecated">&sect;9.6.4.6</a>) are specified
                                    by the string "<code class="literal">removal</code>".
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.5-210-D"></a>
                                    Preview warnings (<a class="xref" href="jls-1.html#jls-1.5" title="1.5.&nbsp;Preview Features">&sect;1.5</a>) are specified
                                    by the string "<code class="literal">preview</code>".
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-9.6.4.5-220"></a>
                     Any other string specifies a non-standard warning. A Java compiler
                     must ignore any such string that it does not recognize.
                  </p>
                  <p class="note">
                     Compiler vendors are encouraged to document the strings they support for
                     <code class="literal">@SuppressWarnings</code>, and to cooperate to ensure that the same strings
                     are recognized across multiple compilers.
                  </p>
               </div>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.6.4.6"></a>9.6.4.6.&nbsp;<code class="literal">@Deprecated</code></h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-9.6.4.6-100"></a>
                     Programmers are sometimes discouraged from using certain program
                     elements (modules, classes, interfaces, fields, methods, and constructors) 
                     because they are considered dangerous or because a better alternative 
                     exists. The annotation interface <code class="literal">Deprecated</code> allows a compiler to warn 
                     about uses of these program elements.
                  </p>
                  <p class="norm-static"><a name="jls-9.6.4.6-110"></a>
                     A <span class="emphasis"><em>deprecated</em></span> program element is a module, class,
                     interface, field, method, or constructor whose declaration is annotated 
                     with <code class="literal">@Deprecated</code>. The manner in which a program element is deprecated
                     depends on the value of the <code class="literal">forRemoval</code> element of
                     the annotation:
                  </p>
                  <div class="norm">
                     <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-110-A"></a>
                                    If <code class="literal">forRemoval=false</code> (the default), then the
                                    program element is <span class="emphasis"><em>ordinarily deprecated</em></span>.
                           </p>
                           <p class="norm"><a name="jls-9.6.4.6-110-A.1"></a>
                                    An ordinarily deprecated program element is not intended to be
                                    removed in a future release, but programmers should nevertheless
                                    migrate away from using it.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-110-B"></a>
                                    If <code class="literal">forRemoval=true</code>, then the program element
                                    is <span class="emphasis"><em>terminally deprecated</em></span>.
                           </p>
                           <p class="norm"><a name="jls-9.6.4.6-110-B.1"></a>
                                    A terminally deprecated program element is intended to be
                                    removed in a future release. Programmers should stop using it or
                                    risk source and binary incompatibilities (<a class="xref" href="jls-13.html#jls-13.2" title="13.2.&nbsp;What Binary Compatibility Is and Is Not">&sect;13.2</a>) 
                                    when upgrading to a newer release.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-warning"><a name="jls-9.6.4.6-200"></a>
                     A Java compiler must produce a <span class="emphasis"><em>deprecation warning</em></span> 
                     when an ordinarily deprecated program element is used 
                     (overridden, invoked, or referenced by name) in the declaration
                     of a program element (whether explicitly or implicitly declared), unless:
                  </p>
                  <div class="norm">
                     <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-200-A"></a>
                                    The use is within a declaration that is itself deprecated,
                                    either ordinarily or terminally; or
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-200-B"></a>
                                    The use is within a declaration that is annotated to suppress
                                    deprecation warnings (<a class="xref" href="jls-9.html#jls-9.6.4.5" title="9.6.4.5.&nbsp;@SuppressWarnings">&sect;9.6.4.5</a>); or
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-200-C"></a>
                                    The  declaration where the use appears
                                    and the declaration of the ordinarily deprecated program element
                                    are both within the same outermost class; or
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-200-D"></a>
                                    The use is within an <code class="literal">import</code> declaration that imports the 
                                    ordinarily deprecated class, interface, or member; or
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-200-E"></a>
                                    The use is within an <code class="literal">exports</code> or <code class="literal">opens</code> directive 
                                    (<a class="xref" href="jls-7.html#jls-7.7.2" title="7.7.2.&nbsp;Exported and Opened Packages">&sect;7.7.2</a>).
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-warning"><a name="jls-9.6.4.6-300"></a>
                     A Java compiler must produce a <span class="emphasis"><em>removal warning</em></span>
                     when a terminally deprecated program element is used (overridden,
                     invoked, or referenced by name) in the declaration of a program
                     element (whether explicitly or implicitly declared), unless:
                  </p>
                  <div class="norm">
                     <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-300-A"></a>
                                    The use is within a declaration that is annotated to suppress
                                    removal warnings (<a class="xref" href="jls-9.html#jls-9.6.4.5" title="9.6.4.5.&nbsp;@SuppressWarnings">&sect;9.6.4.5</a>); or
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-300-B"></a>
                                    The  declaration where the use appears
                                    and the declaration of the terminally deprecated program element
                                    are both within the same outermost class; or
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-300-C"></a>
                                    The use is within an <code class="literal">import</code> declaration that imports the
                                    terminally deprecated class, interface, or member; or
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-300-D"></a>
                                    The use is within an <code class="literal">exports</code> or <code class="literal">opens</code> directive.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="note">Terminal deprecation is sufficiently urgent that the
                     use of a terminally deprecated element will cause a removal warning 
                     <span class="emphasis"><em>even if the using element is itself deprecated</em></span>, 
                     since there is no guarantee that both elements will be removed 
                     at the same time. To dismiss the warning but continue using the element, 
                     the programmer must manually acknowledge the risk via an 
                     <code class="literal">@SuppressWarnings</code> annotation.
                  </p>
                  <p class="norm-static"><a name="jls-9.6.4.6-400"></a>
                     No deprecation warning or removal warning is produced when:
                  </p>
                  <div class="norm">
                     <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-400-A"></a>
                                    a local variable or formal parameter is used (referenced by
                                    name), even if the declaration of the local variable or formal
                                    parameter is annotated with <code class="literal">@Deprecated</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-400-B"></a>
                                    the name of a package is used (referenced by a qualified type
                                    name, or an <code class="literal">import</code> declaration, or an <code class="literal">exports</code> or <code class="literal">opens</code>
                                    directive), even if the declaration of the package is annotated
                                    with <code class="literal">@Deprecated</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-9.6.4.6-400-C"></a>
                                    the name of a module is used by a qualified <code class="literal">exports</code> or <code class="literal">opens</code>
                                    directive, even if the declaration of the friend module is
                                    annotated with <code class="literal">@Deprecated</code>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="note">
                     A module declaration that exports or opens a package is usually
                     controlled by the same programmer or team that controls the package's
                     declaration. As such, there is little benefit in warning that the
                     package declaration is annotated with <code class="literal">@Deprecated</code> when the package
                     is exported or opened by the module declaration. In contrast, a module
                     declaration that exports or opens a package <span class="emphasis"><em>to a friend
                           module</em></span> is usually not controlled by the same programmer or
                     team that controls the friend module. Simply exporting or opening the
                     package does not make the module declaration rely on the friend
                     module, so there is little value in warning if the friend module is
                     deprecated; the programmer of the module declaration would almost
                     always wish to suppress such a warning.
                  </p>
                  <p class="note">
                     The only implicit declaration that can cause a deprecation warning or
                     removal warning is a container annotation (<a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Interface">&sect;9.7.5</a>). 
                     Namely, if <span class="type">T</span> is a repeatable annotation interface and <span class="type">TC</span> is its 
                     containing annotation interface, and <span class="type">TC</span> is deprecated, then repeating
                     the <code class="literal">@T</code> annotation will cause a warning. The warning is 
                     due to the implicit <code class="literal">@TC</code> container annotation. 
                     It is strongly discouraged to deprecate a containing annotation
                     interface without deprecating the corresponding repeatable annotation
                     interface.
                  </p>
               </div>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.6.4.7"></a>9.6.4.7.&nbsp;<code class="literal">@SafeVarargs</code></h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-9.6.4.7-100"></a>
                     A variable arity parameter with a non-reifiable element type
                     (<a class="xref" href="jls-4.html#jls-4.7" title="4.7.&nbsp;Reifiable Types">&sect;4.7</a>) can cause heap pollution
                     (<a class="xref" href="jls-4.html#jls-4.12.2" title="4.12.2.&nbsp;Variables of Reference Type">&sect;4.12.2</a>) and give rise to compile-time unchecked
                     warnings (<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>). However, such warnings are
                     uninformative if the body of the variable arity method is well-behaved
                     with respect to the variable arity parameter.
                  </p>
                  <p class="norm-static"><a name="jls-9.6.4.7-110"></a>
                     The annotation interface <code class="literal">SafeVarargs</code>, when used to annotate a method or
                     constructor declaration, makes a programmer assertion that prevents a
                     Java compiler from reporting unchecked warnings for the declaration or
                     invocation of a variable arity method or constructor where the
                     compiler would otherwise do so due to the variable arity parameter
                     having a non-reifiable element type.
                  </p>
                  <p class="note">The annotation <code class="literal">@SafeVarargs</code> has non-local effects
                     because it suppresses unchecked warnings at method invocation
                     expressions, in addition to an unchecked warning pertaining to the
                     declaration of the variable arity method itself
                     (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>). In contrast, the annotation
                     <code class="literal">@SuppressWarnings</code><code class="literal">("unchecked")</code> has local effects
                     because it only suppresses unchecked warnings pertaining to the
                     declaration of a method.
                  </p>
                  <div class="informalexample">
                     <p class="note">The canonical target for <code class="literal">@SafeVarargs</code> is a method
                        like <code class="literal">java.util.Collections.addAll</code>, whose
                        declaration starts with:
                     </p><pre class="screen">
public static &lt;T&gt; boolean
  addAll(Collection&lt;? super T&gt; c, T... elements)
</pre><p class="note">The variable arity parameter has declared type
                        <code class="literal">T</code><code class="literal">[]</code>, which is non-reifiable. However, the
                        method fundamentally just reads from the input array and adds the
                        elements to a collection, both of which are safe operations with
                        respect to the array. Therefore, any compile-time unchecked warnings
                        at method invocation expressions
                        for <code class="literal">java.util.Collections.addAll</code> are arguably
                        spurious and uninformative. Applying <code class="literal">@SafeVarargs</code> to the method
                        declaration prevents generation of these unchecked warnings at the
                        method invocation expressions.
                     </p>
                  </div>
                  <p class="norm-error"><a name="jls-9.6.4.7-200"></a>
                     It is a compile-time error if a fixed arity method or constructor
                     declaration is annotated with the annotation <code class="literal">@SafeVarargs</code>.
                  </p>
                  <p class="norm-error"><a name="jls-9.6.4.7-210"></a>
                     It is a compile-time error if a variable arity method declaration that
                     is neither <code class="literal">static</code> nor <code class="literal">final</code> nor <code class="literal">private</code> is annotated with the
                     annotation <code class="literal">@SafeVarargs</code>.
                  </p>
                  <p class="note">
                     Since <code class="literal">@SafeVarargs</code> is only applicable to <code class="literal">static</code> methods, <code class="literal">final</code>
                     and/or <code class="literal">private</code> instance methods, and constructors, the annotation is
                     not usable where method overriding occurs. Annotation inheritance only
                     works for annotations on classes (not on methods, interfaces, or
                     constructors), so an <code class="literal">@SafeVarargs</code>-style annotation cannot be passed
                     through instance methods in classes or through interfaces.
                  </p>
               </div>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.6.4.8"></a>9.6.4.8.&nbsp;<code class="literal">@Repeatable</code></h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-9.6.4.8-100"></a>
                     The annotation interface <code class="literal">java.lang.annotation.Repeatable</code> is used on the declaration 
                     of a <span class="emphasis"><em>repeatable annotation interface</em></span> to 
                     indicate its containing annotation interface
                     (<a class="xref" href="jls-9.html#jls-9.6.3" title="9.6.3.&nbsp;Repeatable Annotation Interfaces">&sect;9.6.3</a>).
                  </p>
                  <p class="note">Note that an <code class="literal">@Repeatable</code> meta-annotation on the
                     declaration of <span class="type">A</span>, indicating <span class="type">AC</span>, is <span class="emphasis"><em>not</em></span>
                     sufficient to make <span class="type">AC</span> the containing annotation interface of <span class="type">A</span>. 
                     There are numerous well-formedness rules for <span class="type">AC</span> to be considered the
                     containing annotation interface of <span class="type">A</span>.
                  </p>
               </div>
               <div class="section">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-9.6.4.9"></a>9.6.4.9.&nbsp;<code class="literal">@FunctionalInterface</code></h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-9.6.4.9-100"></a>
                     The annotation interface <code class="literal">FunctionalInterface</code> is used to indicate 
                     that an interface is meant to be a functional interface 
                     (<a class="xref" href="jls-9.html#jls-9.8" title="9.8.&nbsp;Functional Interfaces">&sect;9.8</a>). It facilitates early detection of 
                     inappropriate method declarations appearing in or inherited by 
                     an interface that is meant to be functional.
                  </p>
                  <p class="norm-error"><a name="jls-9.6.4.9-110"></a>It is a
                     compile-time error if an interface declaration is annotated with
                     <code class="literal">@FunctionalInterface</code> but is not, in fact, a functional
                     interface.
                  </p>
                  <p class="norm"><a name="jls-9.6.4.9-200"></a>
                     Because some interfaces are functional incidentally, it is not 
                     necessary or desirable that all declarations of functional 
                     interfaces be annotated with <code class="literal">@FunctionalInterface</code>.
                  </p>
               </div>
            </div>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-9.7"></a>9.7.&nbsp;Annotations
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-9.7-100"></a>
               An  <span class="emphasis"><em>annotation</em></span> is a marker which associates
               information with a program element, but has no effect at run
               time. An annotation denotes a specific instance of an annotation
               interface (<a class="xref" href="jls-9.html#jls-9.6" title="9.6.&nbsp;Annotation Interfaces">&sect;9.6</a>) and usually provides values for 
               the elements of that interface.
            </p>
            <p class="norm"><a name="jls-9.7-200"></a>
               There are three kinds of annotations. The first kind is the most general, 
               while the other kinds are merely shorthands for the first kind.
            </p>
            <div id="jls-9.7-210" class="productionset"><a name="jls-9.7-210"></a>
                 
               <div class="production"><a name="jls-Annotation"></a>
                      
                  <div class="lhs">Annotation:</div>
                      
                  <div class="rhs">
                           <a href="jls-9.html#jls-NormalAnnotation" title="NormalAnnotation">NormalAnnotation</a> <br>
                           <a href="jls-9.html#jls-MarkerAnnotation" title="MarkerAnnotation">MarkerAnnotation</a> <br>
                           <a href="jls-9.html#jls-SingleElementAnnotation" title="SingleElementAnnotation">SingleElementAnnotation</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm"><a name="jls-9.7-220"></a>
               Normal annotations are described in <a class="xref" href="jls-9.html#jls-9.7.1" title="9.7.1.&nbsp;Normal Annotations">&sect;9.7.1</a>,
               marker annotations in <a class="xref" href="jls-9.html#jls-9.7.2" title="9.7.2.&nbsp;Marker Annotations">&sect;9.7.2</a>, and single element
               annotations in <a class="xref" href="jls-9.html#jls-9.7.3" title="9.7.3.&nbsp;Single-Element Annotations">&sect;9.7.3</a>. Annotations may appear at
               various syntactic locations in a program, as described in
               <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a>. The number of annotations of the same
               interface that may appear at a location is determined by the
               interface declaration, as described in <a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Interface">&sect;9.7.5</a>.
            </p>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.7.1"></a>9.7.1.&nbsp;Normal Annotations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.7.1-100"></a>
                  A <span class="emphasis"><em>normal annotation</em></span> specifies the name of an
                  annotation interface and optionally a list of comma-separated 
                  <span class="emphasis"><em>element-value pairs</em></span>. Each pair contains an 
                  <span class="emphasis"><em>element value</em></span> that is associated with
                  an element of the annotation interface (<a class="xref" href="jls-9.html#jls-9.6.1" title="9.6.1.&nbsp;Annotation Interface Elements">&sect;9.6.1</a>).
               </p>
               <div id="jls-9.7.1-110" class="productionset"><a name="jls-9.7.1-110"></a>
                    
                  <div class="production"><a name="jls-NormalAnnotation"></a>
                         
                     <div class="lhs">NormalAnnotation:</div>
                         
                     <div class="rhs">
                              <code class="literal">@</code> <a href="jls-6.html#jls-TypeName" title="TypeName">TypeName</a>
                              <code class="literal">(</code> [<a href="jls-9.html#jls-ElementValuePairList" title="ElementValuePairList">ElementValuePairList</a>] <code class="literal">)</code>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-ElementValuePairList"></a>
                         
                     <div class="lhs">ElementValuePairList:</div>
                         
                     <div class="rhs">
                              <a href="jls-9.html#jls-ElementValuePair" title="ElementValuePair">ElementValuePair</a> {<code class="literal">,</code> <a href="jls-9.html#jls-ElementValuePair" title="ElementValuePair">ElementValuePair</a>}
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-ElementValuePair"></a>
                         
                     <div class="lhs">ElementValuePair:</div>
                         
                     <div class="rhs">
                              <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> <code class="literal">=</code> <a href="jls-9.html#jls-ElementValue" title="ElementValue">ElementValue</a>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-ElementValue"></a>
                         
                     <div class="lhs">ElementValue:</div>
                         
                     <div class="rhs">
                              <a href="jls-15.html#jls-ConditionalExpression" title="ConditionalExpression">ConditionalExpression</a> <br>
                              <a href="jls-9.html#jls-ElementValueArrayInitializer" title="ElementValueArrayInitializer">ElementValueArrayInitializer</a> <br>
                              <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-ElementValueArrayInitializer"></a>
                         
                     <div class="lhs">ElementValueArrayInitializer:</div>
                         
                     <div class="rhs">
                              <code class="literal">{</code> [<a href="jls-9.html#jls-ElementValueList" title="ElementValueList">ElementValueList</a>] [<code class="literal">,</code>] <code class="literal">}</code>
                           
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-ElementValueList"></a>
                         
                     <div class="lhs">ElementValueList:</div>
                         
                     <div class="rhs">
                              <a href="jls-9.html#jls-ElementValue" title="ElementValue">ElementValue</a> {<code class="literal">,</code> <a href="jls-9.html#jls-ElementValue" title="ElementValue">ElementValue</a>}
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="note">Note that the at sign (<code class="literal">@</code>) is a token unto itself
                  (<a class="xref" href="jls-3.html#jls-3.11" title="3.11.&nbsp;Separators">&sect;3.11</a>). It is possible to put whitespace between
                  it and the <span class="emphasis"><em>TypeName</em></span>, but this is discouraged as a matter of
                  style.
               </p>
               <p class="norm-static"><a name="jls-9.7.1-120"></a>
                  The <span class="emphasis"><em>TypeName</em></span> specifies the annotation interface corresponding to the
                  annotation. The annotation is said to be "of" that interface.
               </p>
               <p class="norm-error"><a name="jls-9.7.1-130"></a>
                  The <span class="emphasis"><em>TypeName</em></span> must name an accessible annotation interface
                  (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>), or a compile-time error occurs.
               </p>
               <p class="norm-error"><a name="jls-9.7.1-200"></a>
                  The <span class="emphasis"><em>Identifier</em></span> in an element-value pair must be the simple name of
                  one of the elements (that is, methods) of the annotation interface,
                  or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-9.7.1-210"></a>
                  The return type of this method defines the <span class="emphasis"><em>element
                        type</em></span> of the element-value pair.
               </p>
               <p class="norm-static"><a name="jls-9.7.1-220"></a>
                  If the element type is an array type, then it is not required to use
                  curly braces to specify the element value of the element-value
                  pair. If the element value is not an <span class="emphasis"><em>ElementValueArrayInitializer</em></span>,
                  then an array value whose sole element is the element value is
                  associated with the element. If the element value is an
                  <span class="emphasis"><em>ElementValueArrayInitializer</em></span>, then the array value represented by the
                  <span class="emphasis"><em>ElementValueArrayInitializer</em></span> is associated with the element.
               </p>
               <p class="norm-error"><a name="jls-9.7.1-300"></a>
                  It is a compile-time error if the element type is
                  not <span class="emphasis"><em>commensurate</em></span> with the element value. An
                  element type <span class="type">T</span> is commensurate with an element value <code class="varname">v</code>
                  if and only if one of the following is true:
               </p>
               <div class="norm">
                  <ul class="norm" style="list-style-type: disc; ">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.7.1-300-A"></a>
                                 <span class="type">T</span> is an array type <span class="type">E</span><code class="literal">[]</code>, and either:
                        </p>
                        <div class="norm">
                           <ul class="norm" style="list-style-type: circle; ">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-9.7.1-300-A-A"></a>
                                    	  If <code class="varname">v</code> is a <span class="emphasis"><em>ConditionalExpression</em></span> or
                                    	  an <span class="emphasis"><em>Annotation</em></span>, then <code class="varname">v</code> is commensurate
                                    	  with  <span class="type">E</span>; or
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-9.7.1-300-A-B"></a>
                                    	  If <code class="varname">v</code> is an <span class="emphasis"><em>ElementValueArrayInitializer</em></span>, then each element
                                    	  value that <code class="varname">v</code> contains is commensurate with <span class="type">E</span>.
                                 </p>
                                 <p class="note">An <span class="emphasis"><em>ElementValueArrayInitializer</em></span> is similar
                                    	  to a normal array initializer (<a class="xref" href="jls-10.html#jls-10.6" title="10.6.&nbsp;Array Initializers">&sect;10.6</a>),
                                    	  except that an <span class="emphasis"><em>ElementValueArrayInitializer</em></span> may syntactically
                                    	  contain annotations as well as expressions and nested
                                    	  initializers. However, nested initializers are not semantically
                                    	  legal in an <span class="emphasis"><em>ElementValueArrayInitializer</em></span> because they are
                                    	  never commensurate with array-typed elements in annotation
                                    	  interface declarations (nested array types not permitted).
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.7.1-300-B"></a>
                                 <span class="type">T</span> is not an array type, and the type of <code class="varname">v</code> is assignment
                                 compatible (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>) with <span class="type">T</span>, and:
                        </p>
                        <div class="norm">
                           <ul class="norm" style="list-style-type: circle; ">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-9.7.1-300-B-A"></a>
                                    	  If <span class="type">T</span> is a primitive type or <code class="literal">String</code>, then <code class="varname">v</code> is a
                                    	  constant expression (<a class="xref" href="jls-15.html#jls-15.29" title="15.29.&nbsp;Constant Expressions">&sect;15.29</a>).
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-9.7.1-300-B-B"></a>
                                    	  If <span class="type">T</span> is <code class="literal">Class</code> or an invocation of <code class="literal">Class</code>
                                              (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>), then <code class="varname">v</code> is a
                                              class literal (<a class="xref" href="jls-15.html#jls-15.8.2" title="15.8.2.&nbsp;Class Literals">&sect;15.8.2</a>).
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-9.7.1-300-B-C"></a>
                                    	  If <span class="type">T</span> is an enum class type (<a class="xref" href="jls-8.html#jls-8.9" title="8.9.&nbsp;Enum Classes">&sect;8.9</a>),
                                    	  then <code class="varname">v</code> is an enum constant (<a class="xref" href="jls-8.html#jls-8.9.1" title="8.9.1.&nbsp;Enum Constants">&sect;8.9.1</a>).
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-9.7.1-300-B-D"></a>
                                    	  <code class="varname">v</code> is not <code class="literal">null</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="note">Note that if <span class="type">T</span> is not an array type or an
                  annotation interface, the element value must be a
                  <span class="emphasis"><em>ConditionalExpression</em></span> (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>).
                  The use of <span class="emphasis"><em>ConditionalExpression</em></span> rather than a more
                  general production like <span class="emphasis"><em>Expression</em></span> is a syntactic
                  trick to prevent assignment expressions as element values. Since an
                  assignment expression is not a constant expression, it cannot be a
                  commensurate element value for a primitive or <code class="literal">String</code>-typed
                  element.
               </p>
               <p class="norm-error"><a name="jls-9.7.1-400"></a>
                  A normal annotation must contain an element-value pair for every
                  element of the corresponding annotation interface, except for those
                  elements with default values, or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-9.7.1-410"></a>
                  A normal annotation may, but is not required to, contain element-value
                  pairs for elements with default values.
               </p>
               <p class="note">It is customary, though not required, that
                  element-value pairs in an annotation are presented in the same order
                  as the corresponding elements in the annotation interface declaration.
               </p>
               <p class="norm-static"><a name="jls-9.7.1-500"></a>
                  An annotation on an annotation interface declaration is known as
                  a <span class="emphasis"><em>meta-annotation</em></span>.
               </p>
               <p class="norm-static"><a name="jls-9.7.1-510"></a>
                  An annotation of interface <span class="type">A</span> may appear as a meta-annotation on the
                  declaration of the interface <span class="type">A</span> itself. More generally, circularities in
                  the transitive closure of the "annotates" relation are permitted.
               </p>
               <p class="note">For example, it is legal to annotate the declaration
                  of an annotation interface <span class="type">S</span> with a meta-annotation of interface <span class="type">T</span>,
                  and to annotate <span class="type">T</span>'s own declaration with a meta-annotation of interface
                  <span class="type">S</span>. The predefined annotation interfaces (<a class="xref" href="jls-9.html#jls-9.6.4" title="9.6.4.&nbsp;Predefined Annotation Interfaces">&sect;9.6.4</a>)
                  contain several such circularities.
               </p>
               <div class="example"><a name="d5e19162"></a><p class="title"><b>Example&nbsp;9.7.1-1.&nbsp;Normal Annotations</b></p>
                  <div class="example-contents">
                     <p class="note">Here is an example of a normal annotation using the
                        annotation interface from <a class="xref" href="jls-9.html#jls-9.6.1" title="9.6.1.&nbsp;Annotation Interface Elements">&sect;9.6.1</a>:
                     </p><pre class="programlisting">

@RequestForEnhancement(
    id       = 2868724,
    synopsis = "Provide time-travel functionality",
    engineer = "Mr. Peabody",
    date     = "4/1/2004"
)
public static void travelThroughTime(Date destination) { ... }

</pre><p class="note">Here is an example of a normal annotation that takes
                        advantage of default values, using the annotation interface from
                        <a class="xref" href="jls-9.html#jls-9.6.2" title="9.6.2.&nbsp;Defaults for Annotation Interface Elements">&sect;9.6.2</a>:
                     </p><pre class="programlisting">

@RequestForEnhancement(
    id       = 4561414,
    synopsis = "Balance the federal budget"
)
public static void balanceFederalBudget() {
    throw new UnsupportedOperationException("Not implemented");
}

</pre></div>
               </div><br class="example-break"></div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.7.2"></a>9.7.2.&nbsp;Marker Annotations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.7.2-100"></a>
                  A <span class="emphasis"><em>marker annotation</em></span> is a shorthand designed for use
                  with marker annotation interfaces (<a class="xref" href="jls-9.html#jls-9.6.1" title="9.6.1.&nbsp;Annotation Interface Elements">&sect;9.6.1</a>).
               </p>
               <div id="jls-9.7.2-110" class="productionset"><a name="jls-9.7.2-110"></a>
                    
                  <div class="production"><a name="jls-MarkerAnnotation"></a>
                         
                     <div class="lhs">MarkerAnnotation:</div>
                         
                     <div class="rhs">
                              <code class="literal">@</code> <a href="jls-6.html#jls-TypeName" title="TypeName">TypeName</a>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-static"><a name="jls-9.7.2-120"></a>
                  It is shorthand for the normal annotation:
               </p><a name="jls-9.7.2-130"></a><pre class="screen">
@<span class="emphasis"><em>TypeName</em></span>()
</pre><p class="norm-static"><a name="jls-9.7.2-200"></a>
                  It is legal to use marker annotations for annotation interfaces with
                  elements, so long as all the elements have default values
                  (<a class="xref" href="jls-9.html#jls-9.6.2" title="9.6.2.&nbsp;Defaults for Annotation Interface Elements">&sect;9.6.2</a>).
               </p>
               <div class="example"><a name="d5e19186"></a><p class="title"><b>Example&nbsp;9.7.2-1.&nbsp;Marker Annotations</b></p>
                  <div class="example-contents">
                     <p class="note">Here is an example using the
                        <code class="literal">Preliminary</code> marker annotation interface from
                        <a class="xref" href="jls-9.html#jls-9.6.1" title="9.6.1.&nbsp;Annotation Interface Elements">&sect;9.6.1</a>:
                     </p><pre class="screen">
@Preliminary public class TimeTravel { ... }
</pre></div>
               </div><br class="example-break"></div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.7.3"></a>9.7.3.&nbsp;Single-Element Annotations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.7.3-100"></a>
                  A <span class="emphasis"><em>single-element annotation</em></span> is a shorthand designed
                  for use with single-element annotation interfaces
                  (<a class="xref" href="jls-9.html#jls-9.6.1" title="9.6.1.&nbsp;Annotation Interface Elements">&sect;9.6.1</a>).
               </p>
               <div id="jls-9.7.3-110" class="productionset"><a name="jls-9.7.3-110"></a>
                    
                  <div class="production"><a name="jls-SingleElementAnnotation"></a>
                         
                     <div class="lhs">SingleElementAnnotation:</div>
                         
                     <div class="rhs">
                              <code class="literal">@</code> <a href="jls-6.html#jls-TypeName" title="TypeName">TypeName</a>
                              <code class="literal">(</code> <a href="jls-9.html#jls-ElementValue" title="ElementValue">ElementValue</a> <code class="literal">)</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-static"><a name="jls-9.7.3-120"></a>
                  It is shorthand for the normal annotation:
               </p><a name="jls-9.7.3-130"></a><pre class="screen">
@<span class="emphasis"><em>TypeName</em></span>(value = <span class="emphasis"><em>ElementValue</em></span>)
</pre><p class="norm-static"><a name="jls-9.7.3-200"></a>
                  It is legal to use single-element annotations for annotation interfaces
                  with multiple elements, so long as one element is named <code class="literal">value</code> and
                  all other elements have default values (<a class="xref" href="jls-9.html#jls-9.6.2" title="9.6.2.&nbsp;Defaults for Annotation Interface Elements">&sect;9.6.2</a>).
               </p>
               <div class="example"><a name="d5e19213"></a><p class="title"><b>Example&nbsp;9.7.3-1.&nbsp;Single-Element Annotations</b></p>
                  <div class="example-contents">
                     <p class="note">The following annotations all use the single-element
                        annotation interfaces from <a class="xref" href="jls-9.html#jls-9.6.1" title="9.6.1.&nbsp;Annotation Interface Elements">&sect;9.6.1</a>.
                     </p>
                     <p class="note">Here is an example of a single-element
                        annotation:
                     </p><pre class="programlisting">

@Copyright("2002 Yoyodyne Propulsion Systems, Inc.")
public class OscillationOverthruster { ... }

</pre><p class="note">Here is an example of an array-valued single-element
                        annotation:
                     </p><pre class="programlisting">

@Endorsers({"Children", "Unscrupulous dentists"})
public class Lollipop { ... }

</pre><p class="note">Here is an example of a single-element array-valued
                        single-element annotation: (note that the curly braces are
                        omitted)
                     </p><pre class="programlisting">

@Endorsers("Epicurus")
public class Pleasure { ... }

</pre><p class="note">Here is an example of a single-element annotation
                        with a <code class="literal">Class</code>-typed element whose value is constrained by a bounded
                        wildcard.
                     </p><pre class="programlisting">

class GorgeousFormatter implements Formatter { ... }

@PrettyPrinter(GorgeousFormatter.class)
public class Petunia { ... }

// Illegal; String is not a subtype of Formatter
@PrettyPrinter(String.class)
public class Begonia { ... }

</pre><p class="note">Here is an example of a single-element
                        annotation that contains a normal annotation:
                     </p><pre class="programlisting">

@Author(@Name(first = "Joe", last = "Hacker"))
public class BitTwiddle { ... }

</pre><p class="note">Here is an example of a single-element annotation
                        that uses an enum class defined inside the annotation interface
                        declaration:
                     </p><pre class="programlisting">

@Quality(Quality.Level.GOOD)
public class Karma { ... }

</pre></div>
               </div><br class="example-break"></div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.7.4"></a>9.7.4.&nbsp;Where Annotations May Appear
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-9.7.4-100"></a>
                  A <span class="emphasis"><em>declaration annotation</em></span> is an annotation that
                  applies to a declaration, and whose annotation interface is applicable in
                  the declaration context (<a class="xref" href="jls-9.html#jls-9.6.4.1" title="9.6.4.1.&nbsp;@Target">&sect;9.6.4.1</a>) represented by
                  that declaration; or an annotation that applies to a class, interface,
                  or type parameter declaration, and whose annotation interface is
                  applicable in type contexts (<a class="xref" href="jls-4.html#jls-4.11" title="4.11.&nbsp;Where Types Are Used">&sect;4.11</a>).
               </p>
               <p class="norm-static"><a name="jls-9.7.4-110"></a>
                  A <span class="emphasis"><em>type annotation</em></span> is an annotation that applies
                  to a type (or any part of a type), and whose annotation interface is
                  applicable in type contexts.
               </p>
               <div class="informalexample">
                  <p class="note">For example, given the field declaration:</p><pre class="screen">@Foo int f;</pre><p class="note"><code class="literal">@Foo</code> is a declaration annotation
                     on <code class="literal">f</code> if <code class="literal">Foo</code> is meta-annotated by
                     <code class="literal">@Target(ElementType.FIELD)</code>, and a type annotation
                     on <code class="literal">int</code> if <code class="literal">Foo</code> is meta-annotated by
                     <code class="literal">@Target(ElementType.TYPE_USE)</code>. It is possible
                     for <code class="literal">@Foo</code> to be both a declaration annotation and a
                     type annotation simultaneously.
                  </p>
                  <p class="note">Type annotations can apply to an array type or any
                     component type thereof (<a class="xref" href="jls-10.html#jls-10.1" title="10.1.&nbsp;Array Types">&sect;10.1</a>). For example,
                     assuming that <code class="literal">A</code>, <code class="literal">B</code>,
                     and <code class="literal">C</code> are annotation interfaces meta-annotated
                     with <code class="literal">@Target(ElementType.TYPE_USE)</code>, then given the
                     field declaration:
                  </p><pre class="screen">@C int @A [] @B [] f;</pre><p class="note"><code class="literal">@A</code> applies to the array type
                     <code class="literal">int</code><code class="literal">[]</code><code class="literal">[]</code>, <code class="literal">@B</code> applies to its
                     component type <code class="literal">int</code><code class="literal">[]</code>, and <code class="literal">@C</code> applies to
                     the element type <code class="literal">int</code>. For more examples, see
                     <a class="xref" href="jls-10.html#jls-10.2" title="10.2.&nbsp;Array Variables">&sect;10.2</a>.
                  </p>
                  <p class="note">An important property of this syntax is that, in two
                     declarations that differ only in the number of array levels, the
                     annotations to the left of the type refer to the same type. For
                     example, <code class="literal">@C</code> applies to the type <code class="literal">int</code> in all of the
                     following declarations:
                  </p><pre class="screen">
@C int f;
@C int[] f;
@C int[][] f;
</pre></div>
               <p class="note">It is customary, though not required, to write
                  declaration annotations before all other modifiers, and type
                  annotations immediately before the type to which they apply.
               </p>
               <p class="norm-static"><a name="jls-9.7.4-200"></a>
                  It is possible for an annotation to appear at a syntactic location in
                  a program where it could plausibly apply to a declaration, or a type,
                  or both. This can happen in any of the  six declaration contexts
                  where modifiers immediately precede the type of the declared entity:
               </p>
               <div class="norm">
                  <ul class="norm" style="list-style-type: disc; ">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.7.4-200-A"></a>
                                 Method declarations (including elements of annotation interfaces)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.7.4-200-B"></a>
                                 Constructor declarations
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.7.4-200-C"></a>
                                 Field declarations (including enum constants)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.7.4-200-D"></a>
                                 Formal and exception parameter declarations
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.7.4-200-E"></a>
                                 Local variable declarations
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.7.4-200-F"></a>
                                 Record component declarations
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-9.7.4-210"></a>
                  The grammar of the Java programming language unambiguously treats annotations at
                  these locations as modifiers for a declaration
                  (<a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a>), but that is purely a syntactic
                  matter. Whether an annotation applies to the declaration or to the
                  type of the declared entity - and thus, whether the annotation is
                  a <span class="emphasis"><em>declaration annotation</em></span> or a <span class="emphasis"><em>type
                        annotation</em></span> - depends on the applicability of the
                  annotation's interface:
               </p>
               <div class="norm">
                  <ul class="norm" style="list-style-type: disc; ">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.7.4-210-A"></a>
                                 If the annotation's interface is applicable in the declaration
                                 context corresponding to the declaration, and not in type
                                 contexts, then the annotation is deemed to apply only to the
                                 declaration.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.7.4-210-B"></a>
                                 If the annotation's interface is applicable in type contexts,
                                 and not in the declaration context corresponding to the
                                 declaration, then the annotation is deemed to apply only to the
                                 type which is closest to the annotation.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.7.4-210-C"></a>
                                 If the annotation's interface is applicable in the declaration
                                 context corresponding to the declaration
                                 <span class="emphasis"><em>and</em></span> in type contexts, then the annotation
                                 is deemed to apply to both the declaration
                                 <span class="emphasis"><em>and</em></span> the type which is closest to the
                                 annotation.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-9.7.4-220"></a>
                  
                  In the second and third cases above, the type which is 
                  <span class="emphasis"><em>closest</em></span> to the annotation is determined as follows:
               </p>
               <div class="norm">
                  <ul class="norm" style="list-style-type: disc; ">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-9.7.4-220-A"></a>
                                 If the annotation appears before a <code class="literal">void</code> method declaration or
                                 a local variable declaration that uses <code class="literal">var</code> (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declarations">&sect;14.4</a>), then there is no closest type. If the
                                 annotation's interface is deemed to apply only to the type which
                                 is closest to the annotation, a compile-time error occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.7.4-220-B"></a>
                                 If the annotation appears before a constructor declaration, 
                                  then the closest type is the type of the newly
                                 constructed object. The type of the newly constructed object is
                                 the fully qualified name of the type immediately enclosing the
                                 constructor declaration. Within that fully qualified name, the
                                 annotation applies to the simple type name indicated by the
                                 constructor declaration.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-9.7.4-220-c"></a>
                                 In all other cases, the closest type is the type written in
                                 source code for the declared entity; if that type is an array
                                 type, then the element type is deemed to be closest to the
                                 annotation.
                        </p>
                        <p class="note">For example, in the field	declaration 
                                 <code class="literal">@Foo public static String f;</code>, the type which
                                 is closest to <code class="literal">@Foo</code> is <code class="literal">String</code>. (If the type
                                 of the field declaration had been written
                                 as <code class="literal">java.lang.String</code>,
                                 then <code class="literal">java.lang.String</code> would be the type
                                 closest to <code class="literal">@Foo</code>, and later rules would
                                 prohibit a type annotation from applying to the package
                                 name <code class="literal">java</code>.)  In the generic method
                                 declaration <code class="literal">@Foo &lt;T&gt; int[] m() {...}</code>,
                                 the type written for the declared entity is <code class="literal">int</code><code class="literal">[]</code>,
                                 so <code class="literal">@Foo</code> applies to the element type
                                 <code class="literal">int</code>.
                        </p>
                        <p class="note">Local variable declarations which do not use
                                 <code class="literal">var</code> are similar to formal parameter declarations of lambda
                                 expressions, in that both allow declaration annotations and type
                                 annotations in source code, but only the type annotations can be
                                 stored in the <code class="literal">class</code> file.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-error"><a name="jls-9.7.4-300"></a>
                  It is a compile-time error if an annotation of interface <span class="type">A</span> is
                  syntactically a modifier for:
               </p>
               <div class="norm">
                  <ul class="norm" style="list-style-type: disc; ">
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.7.4-300-AA"></a>
                                 a module declaration, but <span class="type">A</span> is not applicable to module
                                 declarations.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.7.4-300-A"></a>
                                 a package declaration, but <span class="type">A</span> is not applicable to package
                                 declarations.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.7.4-300-B"></a>
                                 a class or interface declaration, but <span class="type">A</span> is not applicable to
                                 type declarations or in type contexts; or
                        </p>
                        <p class="norm"><a name="jls-9.7.4-300-B.1"></a>
                                 an annotation interface declaration, but <span class="type">A</span> is not applicable
                                 to annotation interface declarations or type declarations
                                 or in type contexts.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.7.4-300-C"></a>
                                 a method declaration (including an element of an annotation
                                 interface), but <span class="type">A</span> is not applicable to method declarations or
                                 in type contexts.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.7.4-300-D"></a>
                                 a constructor declaration, but <span class="type">A</span> is not applicable to
                                 constructor declarations or in type contexts.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.7.4-300-E"></a>
                                 a type parameter declaration of a generic class, interface,
                                 method, or constructor, but <span class="type">A</span> is not applicable to type
                                 parameter declarations or in type contexts.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.7.4-300-F"></a>
                                 a field declaration (or an enum constant), but <span class="type">A</span> is not
                                 applicable to field declarations or in type contexts.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.7.4-300-G"></a>
                                 a formal or exception parameter declaration, but <span class="type">A</span> is not
                                 applicable to formal and exception parameter declarations
                                 or in type contexts.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.7.4-300-H"></a>
                                 a receiver parameter, but <span class="type">A</span> is not applicable in type
                                 contexts.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.7.4-300-I"></a>
                                 a local variable declaration in either a statement or a pattern, but
                                 <span class="type">A</span> is not applicable to local variable declarations or in
                                 type contexts.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.7.4-300-J"></a>
                                 a record component, but <span class="type">A</span> is not applicable to record
                                 component declarations, field declarations, method declarations,
                                 or formal and exception parameter declarations, or in type contexts.
                               
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">Six of these eleven clauses mention "... or in type
                  contexts" because they characterize the six syntactic locations,
                  mentioned earlier in this section, where an annotation could plausibly
                  apply to a declaration or a type. Furthermore, two of the eleven
                  clauses - for class and interface declarations, and for type parameter
                  declarations - mention "... or in type contexts" because it is sometimes
                  convenient to be able to apply an annotation whose interface is
                  meta-annotated with <code class="literal">@Target(ElementType.TYPE_USE)</code>
                  (thus, applicable in type contexts) to the declaration of a class,
                  interface, or type parameter.
               </p>
               <p class="norm"><a name="jls-9.7.4-400"></a>
                  A type annotation is <span class="emphasis"><em>admissible</em></span> if both of the
                  following are true:
               </p>
               <div class="norm">
                  <ul class="norm" style="list-style-type: disc; ">
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.7.4-400-A"></a>
                                 The simple name to which the annotation is closest is classified
                                 as a <span class="emphasis"><em>TypeName</em></span>, not a <span class="emphasis"><em>PackageName</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-9.7.4-400-B"></a>
                                 If the simple name to which the annotation is closest is
                                 followed by "<code class="literal">.</code>" and another <span class="emphasis"><em>TypeName</em></span> - that is, the
                                 annotation appears as <code class="literal">@Foo T.U</code> -
                                 then <code class="literal">U</code> denotes an inner class
                                 of <code class="literal">T</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">The intuition behind the second clause is that if
                  <code class="literal">Outer.this</code> is legal in a nested class enclosed
                  by <code class="literal">Outer</code>, then <code class="literal">Outer</code> may be
                  annotated because it represents the type of some object at run
                  time. On the other hand, if <code class="literal">Outer.this</code> is not legal
                  - because the class where it appears has no enclosing instance
                  of <code class="literal">Outer</code> at run time -
                  then <code class="literal">Outer</code> may not be annotated because it is
                  logically just a name, akin to components of a package name in a fully
                  qualified type name.
               </p>
               <div class="informalexample">
                  <p class="note">For example, in the following program, it is not
                     possible to write <code class="literal">A.this</code> in the body of
                     <code class="literal">B</code>, as <code class="literal">B</code> has no lexically
                     enclosing instances. Therefore, it is not possible to apply
                     <code class="literal">@Foo</code> to <code class="literal">A</code> in the type
                     <code class="literal">A.B</code>, because <code class="literal">A</code> is logically just
                     a name, not a type.
                  </p><pre class="programlisting">

@Target(ElementType.TYPE_USE)
@interface Foo {}

class A {
    static class B {}
}

@Foo A.B x;  // Illegal 

</pre><p class="note">On the other hand, in the following program, it is
                     possible to write <code class="literal">C.this</code> in the body
                     of <code class="literal">D</code>. Therefore, it is possible to
                     apply <code class="literal">@Foo</code> to <code class="literal">C</code> in the
                     type <code class="literal">C.D</code>, because <code class="literal">C</code> represents
                     the type of some object at run time.
                  </p><pre class="programlisting">

@Target(ElementType.TYPE_USE)
@interface Foo {}

class Test {
    static class C {
        class D {}
    }

    @Foo C.D x;  // Legal 
}

</pre></div>
               <p class="norm-error"><a name="jls-9.7.4-410"></a>
                  It is a compile-time error if an annotation of interface <span class="type">A</span> applies to
                  the outermost level of a type in a type context, and <span class="type">A</span> is not applicable
                  in type contexts or the declaration context (if any) which occupies
                  the same syntactic location.
               </p>
               <p class="norm-error"><a name="jls-9.7.4-420"></a>
                  It is a compile-time error if an annotation of interface <span class="type">A</span> applies to
                  a part of a type (that is, not the outermost level) in a type context,
                  and <span class="type">A</span> is not applicable in type contexts.
               </p>
               <p class="norm-error"><a name="jls-9.7.4-430"></a>
                  It is a compile-time error if an annotation of interface <span class="type">A</span> applies to
                  a type (or any part of a type) in a type context, and <span class="type">A</span> is applicable
                  in type contexts, but the annotation is not admissible.
               </p>
               <p class="note">For example, assume an annotation
                  interface <code class="literal">TA</code> which is meta-annotated with just
                  <code class="literal">@Target(ElementType.TYPE_USE)</code>. The terms
                  <code class="literal">@TA java.lang.Object</code> and <code class="literal">java.@TA
                     lang.Object</code> are illegal because the simple name to
                  which <code class="literal">@TA</code> is closest is classified as a package
                  name. On the other hand, <code class="literal">java.lang.@TA Object</code> is
                  legal.
               </p>
               <p class="note">Note that the illegal terms are illegal
                  "everywhere". The ban on annotating package names applies broadly: to
                  locations which are solely type contexts, such as <code class="literal">class
                     ... extends @TA java.lang.Object {...}</code>, and to locations
                  which are both declaration and type contexts, such as <code class="literal">@TA
                     java.lang.Object f;</code>. (There are no locations which are
                  solely declaration contexts where a package name could be annotated,
                  as package, class, interface, and type parameter declarations
                  introduce only simple names.)
               </p>
               <p class="note">If <code class="literal">TA</code> is additionally
                  meta-annotated with <code class="literal">@Target(ElementType.FIELD)</code>,
                  then the term <code class="literal">@TA java.lang.Object</code> is legal in
                  locations which are both declaration and type contexts, such as a
                  field declaration <code class="literal">@TA java.lang.Object
                     f;</code>. Here, <code class="literal">@TA</code> is deemed to apply to the
                  declaration of <code class="literal">f</code> (and not to the type
                  <code class="literal">java.lang.Object</code>) because <code class="literal">TA</code>
                  is applicable in the field declaration context.
               </p>
            </div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-9.7.5"></a>9.7.5.&nbsp;Multiple Annotations of the Same Interface
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-9.7.5-100"></a>
                  It is a compile-time error if multiple annotations of the same interface
                  <span class="type">A</span> appear in a declaration context or type context, unless <span class="type">A</span> is
                  repeatable (<a class="xref" href="jls-9.html#jls-9.6.3" title="9.6.3.&nbsp;Repeatable Annotation Interfaces">&sect;9.6.3</a>) and both <span class="type">A</span> and the containing
                  annotation interface of <span class="type">A</span> are applicable in the declaration context or
                  type context (<a class="xref" href="jls-9.html#jls-9.6.4.1" title="9.6.4.1.&nbsp;@Target">&sect;9.6.4.1</a>).
               </p>
               <p class="note">It is customary, though not required, for multiple
                  annotations of the same interface to appear consecutively.
               </p>
               <p class="norm-static"><a name="jls-9.7.5-200"></a>
                  If a declaration context or type context has multiple annotations of a
                  repeatable annotation interface <span class="type">A</span>, then it is as if the context has no
                  explicitly declared annotations of interface <span class="type">A</span> and one implicitly
                  declared annotation of the containing annotation interface of <span class="type">A</span>.
               </p>
               <p class="norm-static"><a name="jls-9.7.5-210"></a>
                  The implicitly declared annotation is called the <span class="emphasis"><em>container
                        annotation</em></span>, and the multiple annotations of interface <span class="type">A</span>
                  which appeared in the context are called the <span class="emphasis"><em>base
                        annotations</em></span>. The elements of the (array-typed) <code class="literal">value</code>
                  element of the container annotation are all the base annotations in
                  the left-to-right order in which they appeared in the context.
               </p>
               <p class="norm-error"><a name="jls-9.7.5-300"></a>
                  It is a compile-time error if, in a declaration context or type context,
                  there are multiple annotations of a repeatable annotation interface <span class="type">A</span>
                  and any annotations of the containing annotation interface of <span class="type">A</span>.
               </p>
               <p class="note">In other words, it is not possible to repeat
                  annotations where an annotation of the same interface as their container
                  also appears. This prohibits obtuse code like:
               </p><pre class="programlisting">

@Foo(0) @Foo(1) @FooContainer({@Foo(2)})
class A {}

</pre><p class="note">If this code was legal, then multiple levels of
                  containment would be needed: first the base annotations of interface
                  <code class="literal">Foo</code> would be contained by an implicitly
                  declared container annotation of interface <code class="literal">FooContainer</code>,
                  then that annotation and the explicitly declared annotation of
                  interface <code class="literal">FooContainer</code> would be contained in yet
                  another implicitly declared annotation. This complexity is undesirable
                  in the judgment of the designers of the Java programming language. Another approach,
                  treating the base annotations of interface <code class="literal">Foo</code> as
                  if they had occurred alongside <code class="literal">@Foo(2)</code> in the
                  explicit <code class="literal">@FooContainer</code> annotation, is undesirable
                  because it could change how reflective programs interpret the
                  <code class="literal">@FooContainer</code> annotation.
               </p>
               <p class="norm-error"><a name="jls-9.7.5-310"></a>
                  It is a compile-time error if, in a declaration context or type context,
                  there is one annotation of a repeatable annotation interface <span class="type">A</span> and
                  multiple annotations of the containing annotation interface of <span class="type">A</span>.
               </p>
               <p class="note">This rule is designed to allow the following
                  code:
               </p><pre class="programlisting">

@Foo(1) @FooContainer({@Foo(2)})
class A {}

</pre><p class="note">With only one base annotation of the repeatable
                  annotation interface <code class="literal">Foo</code>, no container annotation is
                  implicitly declared, even if <code class="literal">FooContainer</code> is the
                  containing annotation interface of <code class="literal">Foo</code>. However,
                  repeating the annotation of interface <code class="literal">FooContainer</code>, as
                  in:
               </p><pre class="programlisting">

@Foo(1) @FooContainer({@Foo(2)}) @FooContainer({@Foo(3)})
class A {}

</pre><p class="note">is prohibited, even if <code class="literal">FooContainer</code>
                  is repeatable with a containing annotation interface of its own.
                  It is obtuse to repeat annotations which are themselves containers
                  when an annotation of the underlying repeatable interface is present.
               </p>
            </div>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-9.8"></a>9.8.&nbsp;Functional Interfaces
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-9.8-100"></a>
               A <span class="emphasis"><em>functional interface</em></span> is an interface that is
               not declared <code class="literal">sealed</code> and has just one <code class="literal">abstract</code> method (aside from the
               methods of <code class="literal">Object</code>), and thus represents a single function
               contract. This "single" method may take the form of multiple <code class="literal">abstract</code>
               methods with override-equivalent signatures inherited from
               superinterfaces; in this case, the inherited methods logically
               represent a single method.
            </p>
            <p class="norm-static"><a name="jls-9.8-110"></a>
               For an interface <span class="type">I</span> that is not declared <code class="literal">sealed</code>, let <code class="varname">M</code> be the set
               of <code class="literal">abstract</code> methods that are members of <span class="type">I</span> that do not have the
               same signature as any <code class="literal">public</code> instance method of the class <code class="literal">Object</code>
               (<a class="xref" href="jls-4.html#jls-4.3.2" title="4.3.2.&nbsp;The Class Object">&sect;4.3.2</a>).  Then, <span class="type">I</span> is a <span class="emphasis"><em>functional
                     interface</em></span> if there exists a method <code class="varname">m</code> in <code class="varname">M</code> for which
               both of the following are true:
            </p>
            <div class="norm">
               <ul class="norm" style="list-style-type: disc; ">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.8-110-A"></a>
                              The signature of <code class="varname">m</code> is a subsignature (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) 
                              of every method's signature in <code class="varname">M</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.8-110-B"></a>
                              <code class="varname">m</code> is return-type-substitutable (<a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Result">&sect;8.4.5</a>)
                              for every method in <code class="varname">M</code>.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-9.8-120"></a>
               In addition to the usual process of creating an interface instance by
               declaring and instantiating a class (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>),
               instances of functional interfaces can be created with method
               reference expressions and lambda expressions
               (<a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Method Reference Expressions">&sect;15.13</a>, <a class="xref" href="jls-15.html#jls-15.27" title="15.27.&nbsp;Lambda Expressions">&sect;15.27</a>).
            </p>
            <p class="note">The definition of <span class="emphasis"><em>functional
                     interface</em></span> excludes methods in an interface that are also
               <code class="literal">public</code> methods in <code class="literal">Object</code>. This is to allow functional treatment of
               an interface like <code class="literal">java.util.Comparator&lt;T&gt;</code>
               that declares multiple <code class="literal">abstract</code> methods of which only one is really
               "new" - <code class="literal">int compare(T,T)</code>. The other
               - <code class="literal">boolean equals(Object)</code> - is an explicit
               declaration of an <code class="literal">abstract</code> method that would otherwise be implicitly
               declared in the interface (<a class="xref" href="jls-9.html#jls-9.2" title="9.2.&nbsp;Interface Members">&sect;9.2</a>) and
               automatically implemented by every class that <code class="literal">implements</code> the interface.
            </p>
            <p class="note">Note that if non-<code class="literal">public</code> methods of <code class="literal">Object</code>, such
               as <code class="literal">clone()</code>, are explicitly declared in an interface
               as <code class="literal">public</code>, they are <span class="emphasis"><em>not</em></span> automatically
               implemented by every class that <code class="literal">implements</code> the interface. The
               implementation inherited from <code class="literal">Object</code> is <code class="literal">protected</code> while the
               interface method is <code class="literal">public</code>, so the only way to implement the
               interface would be for a class to override the non-<code class="literal">public</code> <code class="literal">Object</code>
               method with a <code class="literal">public</code> method.
            </p>
            <div class="example"><a name="d5e19543"></a><p class="title"><b>Example&nbsp;9.8-1.&nbsp;Functional Interfaces</b></p>
               <div class="example-contents">
                  <p class="note">A simple example of a functional interface is:</p><pre class="screen">
interface Runnable {
    void run();
}
</pre><p class="note">The following interface is not functional because it
                     declares nothing which is not already a member of <code class="literal">Object</code>:
                  </p><pre class="screen">
interface NonFunc {
    boolean equals(Object obj);
}
</pre><p class="note">However, its subinterface can be functional by
                     declaring an <code class="literal">abstract</code> method which is not a member of
                     <code class="literal">Object</code>:
                  </p><pre class="screen">
interface Func extends NonFunc {
    int compare(String o1, String o2);
}
</pre><p class="note">Similarly, the well known interface
                     <code class="literal">java.util.Comparator&lt;T&gt;</code> is functional because
                     it has one <code class="literal">abstract</code> non-<code class="literal">Object</code> method:
                  </p><pre class="screen">
interface Comparator&lt;T&gt; {
    boolean equals(Object obj);
    int compare(T o1, T o2);
}
</pre><p class="note">The following interface is not functional because
                     while it only declares one <code class="literal">abstract</code> method which is not a member of
                     <code class="literal">Object</code>, it declares <span class="emphasis"><em>two</em></span> <code class="literal">abstract</code> methods
                     which are not <code class="literal">public</code> members of <code class="literal">Object</code>:
                  </p><pre class="screen">
interface Foo {
    int m();
    Object clone();
}
</pre></div>
            </div><br class="example-break"><div class="example"><a name="d5e19567"></a><p class="title"><b>Example&nbsp;9.8-2.&nbsp;Functional Interfaces and Erasure</b></p>
               <div class="example-contents">
                  <p class="note">In the following interface
                     hierarchy, <code class="literal">Z</code> is a functional interface because
                     while it inherits two <code class="literal">abstract</code> methods which are not members of
                     <code class="literal">Object</code>, they have the same signature, so the inherited methods
                     logically represent a single method:
                  </p><pre class="screen">
interface X { int m(Iterable&lt;String&gt; arg); }
interface Y { int m(Iterable&lt;String&gt; arg); }
interface Z extends X, Y {}
</pre><p class="note">Similarly, <code class="literal">Z</code> is a functional
                     interface in the following interface hierarchy
                     because <code class="literal">Y.m</code> is a subsignature
                     of <code class="literal">X.m</code> and is return-type-substitutable
                     for <code class="literal">X.m</code>:
                  </p><pre class="screen">
interface X { Iterable m(Iterable&lt;String&gt; arg); }
interface Y { Iterable&lt;String&gt; m(Iterable arg); }
interface Z extends X, Y {}
</pre><p class="note">The definition of <span class="emphasis"><em>functional
                           interface</em></span> respects the fact that an interface cannot have
                     two members which are not subsignatures of each other, yet have the
                     same erasure (<a class="xref" href="jls-9.html#jls-9.4.1.2" title="9.4.1.2.&nbsp;Requirements in Overriding">&sect;9.4.1.2</a>). Thus, in the following
                     three interface hierarchies where <code class="literal">Z</code> causes a
                     compile-time error, <code class="literal">Z</code> is not a functional
                     interface: (because none of its <code class="literal">abstract</code> members are subsignatures
                     of all other <code class="literal">abstract</code> members)
                  </p><pre class="screen">
interface X { int m(Iterable&lt;String&gt; arg); }
interface Y { int m(Iterable&lt;Integer&gt; arg); }
interface Z extends X, Y {}

interface X { int m(Iterable&lt;String&gt; arg, Class c); }
interface Y { int m(Iterable arg, Class&lt;?&gt; c); }
interface Z extends X, Y {}

interface X&lt;T&gt; { void m(T arg); }
interface Y&lt;T&gt; { void m(T arg); }
interface Z&lt;A, B&gt; extends X&lt;A&gt;, Y&lt;B&gt; {}
</pre><p class="note">Similarly, the definition of "functional interface"
                     respects the fact that an interface may only have methods with
                     override-equivalent signatures if one is return-type-substitutable for
                     all the others. Thus, in the following interface hierarchy
                     where <code class="literal">Z</code> causes a compile-time
                     error, <code class="literal">Z</code> is not a functional interface: (because
                     none of its <code class="literal">abstract</code> members are return-type-substitutable for all
                     other <code class="literal">abstract</code> members)
                  </p><pre class="screen">
interface X { long m(); }
interface Y { int  m(); }
interface Z extends X, Y {}
</pre><p class="note">In the following example, the declarations
                     of <code class="literal">Foo&lt;T,N&gt;</code> and <code class="literal">Bar</code> are
                     legal: in each, the methods called <code class="literal">m</code> are not
                     subsignatures of each other, but do have different erasures. Still,
                     the fact that the methods in each are not subsignatures
                     means <code class="literal">Foo&lt;T,N&gt;</code> and <code class="literal">Bar</code> are
                     not functional interfaces. However, <code class="literal">Baz</code> is a
                     functional interface because the methods it inherits
                     from <code class="literal">Foo&lt;Integer,Integer&gt;</code> have the same
                     signature and so logically represent a single method.
                  </p><pre class="screen">
interface Foo&lt;T, N extends Number&gt; {
    void m(T arg);
    void m(N arg);
}
interface Bar extends Foo&lt;String, Integer&gt; {}
interface Baz extends Foo&lt;Integer, Integer&gt; {}
</pre><p class="note">Finally, the following examples demonstrate the same
                     rules as above, but with generic methods:
                  </p><pre class="screen">
interface Exec { &lt;T&gt; T execute(Action&lt;T&gt; a); }
  // Functional

interface X { &lt;T&gt; T execute(Action&lt;T&gt; a); }
interface Y { &lt;S&gt; S execute(Action&lt;S&gt; a); }
interface Exec extends X, Y {}
  // Functional: signatures are logically "the same"

interface X { &lt;T&gt;   T execute(Action&lt;T&gt; a); }
interface Y { &lt;S,T&gt; S execute(Action&lt;S&gt; a); }
interface Exec extends X, Y {}
  // Error: different signatures, same erasure
</pre></div>
            </div><br class="example-break"><div class="example"><a name="d5e19605"></a><p class="title"><b>Example&nbsp;9.8-3.&nbsp;Generic Functional Interfaces</b></p>
               <div class="example-contents">
                  <p class="note">Functional interfaces can be generic, such
                     as <code class="literal">java.util.function.Predicate&lt;T&gt;</code>. Such a
                     functional interface may be parameterized in a way that produces
                     distinct <code class="literal">abstract</code> methods - that is, multiple methods that cannot be
                     legally overridden with a single declaration. For example:
                  </p><pre class="screen">
interface I    { Object m(Class c); }
interface J&lt;S&gt; { S m(Class&lt;?&gt; c); }
interface K&lt;T&gt; { T m(Class&lt;?&gt; c); }
interface Functional&lt;S,T&gt; extends I, J&lt;S&gt;, K&lt;T&gt; {}
</pre><p class="note"><code class="literal">Functional&lt;S,T&gt;</code> is a
                     functional interface - <code class="literal">I.m</code> is
                     return-type-substitutable for <code class="literal">J.m</code>
                     and <code class="literal">K.m</code> - but the functional interface
                     type <code class="literal">Functional&lt;String,Integer&gt;</code> clearly
                     cannot be implemented with a single method. However, other
                     parameterizations of <code class="literal">Functional&lt;S,T&gt;</code> which
                     are functional interface types are possible.
                  </p>
               </div>
            </div><br class="example-break"><p class="norm-static"><a name="jls-9.8-200"></a>
               The declaration of a functional interface allows
               a <span class="emphasis"><em>functional interface type</em></span> to be used in a
               program. There are four kinds of functional interface type:
            </p>
            <div class="norm">
               <ul class="norm" style="list-style-type: disc; ">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.8-200-A"></a>
                              The type of a non-generic (<a class="xref" href="jls-6.html#jls-6.1" title="6.1.&nbsp;Declarations">&sect;6.1</a>) functional
                              interface
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.8-200-B"></a>
                              A parameterized type that is a parameterization
                              (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) of a generic functional
                              interface
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.8-200-C"></a>
                              The raw type (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>) of a generic functional
                              interface
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.8-200-D"></a>
                              An intersection type (<a class="xref" href="jls-4.html#jls-4.9" title="4.9.&nbsp;Intersection Types">&sect;4.9</a>) that induces a
                              notional functional interface
                     </p>
                  </li>
               </ul>
            </div>
            <p class="note">In special circumstances, it is useful to treat an
               intersection type as a functional interface type. Typically, this will
               look like an intersection of a functional interface type with one or
               more marker interface types, such as <code class="literal">Runnable &amp;
                  <code class="literal">java.io.Serializable</code></code>. Such an intersection can be used in casts
               (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>) that force a lambda expression to
               conform to a certain type. If one of the interface types in the
               intersection is <code class="literal">java.io.Serializable</code>, special run-time support for
               serialization is triggered (<a class="xref" href="jls-15.html#jls-15.27.4" title="15.27.4.&nbsp;Run-Time Evaluation of Lambda Expressions">&sect;15.27.4</a>).
            </p>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-9.9"></a>9.9.&nbsp;Function Types
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-9.9-100"></a>
               The <span class="emphasis"><em>function type</em></span> of a functional interface <span class="type">I</span>
               is a method type (<a class="xref" href="jls-8.html#jls-8.2" title="8.2.&nbsp;Class Members">&sect;8.2</a>) that can be used to
               override (<a class="xref" href="jls-8.html#jls-8.4.8" title="8.4.8.&nbsp;Inheritance, Overriding, and Hiding">&sect;8.4.8</a>) the <code class="literal">abstract</code> method(s) of <span class="type">I</span>.
            </p>
            <p class="norm-static"><a name="jls-9.9-110"></a>
               Let <code class="varname">M</code> be the set of <code class="literal">abstract</code> methods defined for <span class="type">I</span>. The function
               type of <span class="type">I</span> consists of the following:
            </p>
            <div class="norm">
               <ul class="norm" style="list-style-type: disc; ">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.9-110-A"></a>
                              Type parameters, formal parameter types, and return type:
                     </p>
                     <p class="norm-static"><a name="jls-9.9-110-A.1"></a>
                              Let <code class="varname">m</code> be a method in <code class="varname">M</code> with:
                     </p>
                     <div class="orderedlist">
                        <ol class="orderedlist" type="1">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-9.9-110-A.1-A"></a>
                                 	  a signature that is a subsignature of every method's
                                 	  signature in <code class="varname">M</code>; and
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-9.9-110-A.1-B"></a>
                                 	  a return type <span class="type">R</span> (possibly <code class="literal">void</code>), where either <span class="type">R</span> is the
                                 	  same as every method's return type in <code class="varname">M</code>, or <span class="type">R</span> is a
                                 	  reference type and is a subtype of every method's return
                                 	  type in <code class="varname">M</code> (after adapting for any type parameters
                                 	  (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>) if the two methods have the
                                 	  same signature).
                              </p>
                           </li>
                        </ol>
                     </div>
                     <p class="norm-static"><a name="jls-9.9-110-A.2"></a>
                              If no such method exists, then let <code class="varname">m</code> be a method in <code class="varname">M</code> with:
                     </p>
                     <div class="orderedlist">
                        <ol class="orderedlist" type="1">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-9.9-110-A.2-A"></a>
                                 	  a signature that is a subsignature of every method's
                                 	  signature in <code class="varname">M</code>; and
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-9.9-110-A.2-B"></a>
                                 	  a return type such that <code class="varname">m</code> is return-type-substitutable
                                 	  (<a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Result">&sect;8.4.5</a>) for every method in <code class="varname">M</code>.
                              </p>
                           </li>
                        </ol>
                     </div>
                     <p class="norm-static"><a name="jls-9.9-110-A.3"></a>
                              The function type's type parameters, formal parameter types, and
                              return type are as given by <code class="varname">m</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.9-110-B"></a>
                              <code class="literal">throws</code> clause:
                     </p>
                     <p class="norm-static"><a name="jls-9.9-110-B.1"></a>
                              The function type's <code class="literal">throws</code> clause is derived from the <code class="literal">throws</code>
                              clauses of the methods in <code class="varname">M</code>, as follows:
                     </p>
                     <div class="orderedlist">
                        <ol class="orderedlist" type="1">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-9.9-110-B.1-A"></a>
                                 	  If the function type is generic, the <code class="literal">throws</code> clauses are
                                 	  first adapted to the type parameters of the function type
                                 	  (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>).
                              </p>
                              <p class="norm-static"><a name="jls-9.9-110-B.1-A.1"></a>
                                 	  If the function type is not generic but at least one method
                                 	  in <code class="varname">M</code> is generic, the <code class="literal">throws</code> clauses are first erased.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-9.9-110-B.1-B"></a>
                                 	  Then, the function type's <code class="literal">throws</code> clause includes every
                                 	  type <span class="type">E</span> which satisfies the following constraints:
                              </p>
                              <div class="norm">
                                 <ul class="norm" style="list-style-type: circle; ">
                                    <li class="listitem">
                                       <p class="norm-static"><a name="jls-9.9-110-B.1-B-A"></a>
                                          	      <span class="type">E</span> is mentioned in one of the <code class="literal">throws</code> clauses.
                                       </p>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm-static"><a name="jls-9.9-110-B.1-B-B"></a>
                                          	      For each <code class="literal">throws</code> clause, <span class="type">E</span> is a subtype of some type
                                                        named in that clause.
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </li>
               </ul>
            </div>
            <p class="note">When some return types in <code class="varname">M</code> are raw and others are
               not, the definition of a function type tries to choose the most
               specific type, if possible. For example, if the return types
               are <code class="literal">LinkedList</code>
               and <code class="literal">LinkedList&lt;String&gt;</code>, then the latter is
               immediately chosen as the function type's return type. When there is
               no most specific type, the definition compensates by finding the most
               substitutable return type. For example, if there is a third return
               type, <code class="literal">List&lt;?&gt;</code>, then it is not the case that
               one of the return types is a subtype of every other (as
               raw <code class="literal">LinkedList</code> is not a subtype
               of <code class="literal">List&lt;?&gt;</code>); instead, 
               <code class="literal">LinkedList&lt;String&gt;</code> is chosen as the function
               type's return type because it is return-type-substitutable for
               both <code class="literal">LinkedList</code> and <code class="literal">List&lt;?&gt;</code>.
            </p>
            <p class="note">The goal driving the definition of a function type's
               thrown exception types is to support the invariant that a method with
               the resulting <code class="literal">throws</code> clause could override each <code class="literal">abstract</code> method of
               the functional interface. Per <a class="xref" href="jls-8.html#jls-8.4.6" title="8.4.6.&nbsp;Method Throws">&sect;8.4.6</a>, this means
               the function type cannot throw "more" exceptions than any single
               method in the set <code class="varname">M</code>, so we look for as many exception types as
               possible that are "covered" by every method's <code class="literal">throws</code> clause.
            </p>
            <p class="norm-static"><a name="jls-9.9-200"></a>
               The function type of a functional interface type is specified as
               follows:
            </p>
            <div class="norm">
               <ul class="norm" style="list-style-type: disc; ">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.9-200-A"></a>
                              The function type of the type of a non-generic functional
                              interface <span class="type">I</span> is simply the function type of the functional
                              interface <span class="type">I</span>, as defined above.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.9-200-B"></a>
                              The function type of a parameterized functional interface type
                              <span class="type">I</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>...<span class="type">A<sub>n</sub></span><code class="literal">&gt;</code>, where <span class="type">A<sub>1</sub></span>...<span class="type">A<sub>n</sub></span> are types and
                              the corresponding type parameters of <span class="type">I</span> are <span class="type">P<sub>1</sub></span>...<span class="type">P<sub>n</sub></span>, is
                              derived by applying the substitution <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="type">A<sub>1</sub></span>, ...,
                              <span class="type">P<sub>n</sub></span>:=<span class="type">A<sub>n</sub></span><code class="literal">]</code> to the function type of the generic functional
                              interface <span class="type">I</span><code class="literal">&lt;</code><span class="type">P<sub>1</sub></span>...<span class="type">P<sub>n</sub></span><code class="literal">&gt;</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.9-200-C"></a>
                              The function type of a parameterized functional interface type
                              <span class="type">I</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>...<span class="type">A<sub>n</sub></span><code class="literal">&gt;</code>, where one or more of <span class="type">A<sub>1</sub></span>...<span class="type">A<sub>n</sub></span>
                              is a wildcard, is the function type of
                              the <span class="emphasis"><em>non-wildcard parameterization</em></span> of <span class="type">I</span>,
                              <span class="type">I</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>...<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>. The non-wildcard
                              parameterization is determined as follows.
                     </p>
                     <p class="norm-static"><a name="jls-9.9-200-C.1"></a>
                              Let <span class="type">P<sub>1</sub></span>...<span class="type">P<sub>n</sub></span> be the type parameters of <span class="type">I</span> with corresponding
                              bounds <span class="type">B<sub>1</sub></span>...<span class="type">B<sub>n</sub></span>. For all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                              <span class="emphasis"><em>n</em></span>), <span class="type">T<sub>i</sub></span> is derived according to the form of <span class="type">A<sub>i</sub></span>:
                     </p>
                     <div class="norm">
                        <ul class="norm" style="list-style-type: circle; ">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-9.9-200-C.1-A"></a>
                                 	  If <span class="type">A<sub>i</sub></span> is a type, then <span class="type">T<sub>i</sub></span> = <span class="type">A<sub>i</sub></span>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-9.9-200-C.1-B"></a>
                                 	  If <span class="type">A<sub>i</sub></span> is a wildcard, and the corresponding type
                                 	  parameter's bound, <span class="type">B<sub>i</sub></span>, mentions one of <span class="type">P<sub>1</sub></span>...<span class="type">P<sub>n</sub></span>, then
                                 	  <span class="type">T<sub>i</sub></span> is undefined and there is no function type.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-9.9-200-C.1-C"></a>
                                 	  Otherwise:
                              </p>
                              <div class="norm">
                                 <ul class="norm" style="list-style-type: square; ">
                                    <li class="listitem">
                                       <p class="norm-static"><a name="jls-9.9-200-C.1-C-A"></a>
                                          	      If <span class="type">A<sub>i</sub></span> is an unbound wildcard <code class="literal">?</code>, then <span class="type">T<sub>i</sub></span> = <span class="type">B<sub>i</sub></span>.
                                       </p>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm-static"><a name="jls-9.9-200-C.1-C-B"></a>
                                          	      If <span class="type">A<sub>i</sub></span> is a upper-bounded wildcard <code class="literal">?</code> <code class="literal">extends</code>
                                          	      <span class="type">U<sub>i</sub></span>, then <span class="type">T<sub>i</sub></span> = glb(<span class="type">U<sub>i</sub></span>, <span class="type">B<sub>i</sub></span>)
                                          	      (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>).
                                       </p>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm-static"><a name="jls-9.9-200-C.1-C-C"></a>
                                          	      If <span class="type">A<sub>i</sub></span> is a lower-bounded wildcard <code class="literal">?</code> <code class="literal">super</code> <code class="varname">L<sub>i</sub></code>,
                                          	      then <span class="type">T<sub>i</sub></span> = <code class="varname">L<sub>i</sub></code>.
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.9-200-D"></a>
                              The function type of the raw type of a generic functional
                              interface <span class="type">I</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code> is the erasure of the function
                              type of the generic functional interface
                              <span class="type">I</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-9.9-200-E"></a>
                              The function type of an intersection type that induces a
                              notional functional interface is the function type of the
                              notional functional interface.
                     </p>
                  </li>
               </ul>
            </div>
            <div class="example"><a name="d5e19883"></a><p class="title"><b>Example&nbsp;9.9-1.&nbsp;Function Types</b></p>
               <div class="example-contents">
                  <p class="note">Given the following interfaces:</p><pre class="screen">
interface X { void m() throws IOException; }
interface Y { void m() throws EOFException; }
interface Z { void m() throws ClassNotFoundException; }
</pre><p class="note">the function type of:</p><pre class="screen">
interface XY extends X, Y {}
</pre><p class="note">is:</p><pre class="screen">
()<code class="literal">-&gt;</code>void throws EOFException
</pre><p class="note">while the function type of:</p><pre class="screen">
interface XYZ extends X, Y, Z {}
</pre><p class="note">is:</p><pre class="screen">
()<code class="literal">-&gt;</code>void (throws nothing)
</pre><p class="note">Given the following interfaces:</p><pre class="screen">
interface A {
    List&lt;String&gt; foo(List&lt;String&gt; arg)
      throws IOException, SQLTransientException;
}
interface B {
    List foo(List&lt;String&gt; arg)
      throws EOFException, SQLException, TimeoutException;
}
interface C {
    List foo(List arg) throws Exception;
}
</pre><p class="note">the function type of:</p><pre class="screen">
interface D extends A, B {}
</pre><p class="note">is:</p><pre class="screen">
(List&lt;String&gt;)<code class="literal">-&gt;</code>List&lt;String&gt;
  throws EOFException, SQLTransientException
</pre><p class="note">while the function type of:</p><pre class="screen">
interface E extends A, B, C {}
</pre><p class="note">is:</p><pre class="screen">
(List)<code class="literal">-&gt;</code>List throws EOFException, SQLTransientException
</pre></div>
            </div><br class="example-break"><p class="note">The function type of a functional interface is
               defined nondeterministically: while the signatures in <code class="varname">M</code> are "the
               same", they may be syntactically different
               (<code class="literal">HashMap.Entry</code> and <code class="literal">Map.Entry</code>,
               for example); the return type may be a subtype of every other return
               type, but there may be other return types that
               are <span class="emphasis"><em>also</em></span> subtypes
               (<code class="literal">List&lt;?&gt;</code> and <code class="literal">List&lt;? extends
                  Object&gt;</code>, for example); and the order of thrown types is
               unspecified. These distinctions are subtle, but they can sometimes be
               important. However, function types are not used in the Java programming language in
               such a way that the nondeterminism matters. 
               Note that the return type and <code class="literal">throws</code> clause of a "most specific
               method" are also defined nondeterministically when there are multiple
               <code class="literal">abstract</code> methods (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>).
            </p>
            <p class="note">When a generic functional interface is parameterized
               by wildcards, there are many different instantiations that could
               satisfy the wildcard and produce different function types. For
               example, each of <code class="literal">Predicate&lt;Integer&gt;</code> (function
               type <code class="literal">Integer <code class="literal">-&gt;</code> boolean</code>), 
               <code class="literal">Predicate&lt;Number&gt;</code>
               (function type <code class="literal">Number <code class="literal">-&gt;</code> boolean</code>),
               and <code class="literal">Predicate&lt;Object&gt;</code> (function
               type <code class="literal">Object <code class="literal">-&gt;</code> boolean</code>) is
               a <code class="literal">Predicate&lt;? super Integer&gt;</code>. Sometimes, it
               is possible to known from the context, such as the parameter types of
               a lambda expression, which function type is intended
               (<a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>). Other times, it is necessary to pick
               one; in these circumstances, the bounds are used. (This simple
               strategy cannot guarantee that the resulting type will satisfy certain
               complex bounds, so not all complex cases are supported.)
            </p>
            <div class="example"><a name="d5e19931"></a><p class="title"><b>Example&nbsp;9.9-2.&nbsp;Generic Function Types</b></p>
               <div class="example-contents">
                  <p class="note">A function type may be generic, as a functional
                     interface's <code class="literal">abstract</code> method may be generic. For example, in the
                     following interface hierarchy:
                  </p><pre class="screen">
interface G1 {
    &lt;E extends Exception&gt; Object m() throws E;
}
interface G2 {
    &lt;F extends Exception&gt; String m() throws Exception;
}
interface G extends G1, G2 {}
</pre><p class="note">the function type of <code class="literal">G</code> is:
                  </p><pre class="screen">
&lt;F extends Exception&gt; ()<code class="literal">-&gt;</code>String throws F
</pre><p class="note">A generic function type for a functional interface
                     may be implemented by a method reference expression
                     (<a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Method Reference Expressions">&sect;15.13</a>), but not by a lambda expression
                     (<a class="xref" href="jls-15.html#jls-15.27" title="15.27.&nbsp;Lambda Expressions">&sect;15.27</a>) as there is no syntax for generic lambda
                     expressions.
                  </p>
               </div>
            </div><br class="example-break"></div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="jls-8.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="jls-10.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;8.&nbsp;Classes&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;10.&nbsp;Arrays</td>
            </tr>
         </table>
      </div>
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" class="navfooter">
         <hr><a href="spec-frontmatter.html">
                Legal Notice
              </a></div>
   </body>
</html>